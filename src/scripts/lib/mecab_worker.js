export default function workerFunction() {

    // Chrome
    // let extensionID = "jkaebofgmgllgmbiinlegcoijdcoiinl"
    // let extensionID = "dencpeliodlckbhnmhfkjejkhejpehmj"

    // Edge Chromium
    let extensionID = "hlpbdadceiikiafhiofdhhgegahpjghf"

    const mecabWasmPath = `chrome-extension://${extensionID}/data/mecab.wasm`
    const mecabDataPath = `chrome-extension://${extensionID}/data/mecab.data`

    var Module = (function () {
        var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;

        return (
            function (Module) {
                Module = Module || {};

                var Module = typeof Module !== "undefined" ? Module : {}; if (!Module.expectedDataFileDownloads) { Module.expectedDataFileDownloads = 0; Module.finishedDataFileDownloads = 0 } Module.expectedDataFileDownloads++; (function () { var loadPackage = function (metadata) { var PACKAGE_PATH; if (typeof window === "object") { PACKAGE_PATH = window["encodeURIComponent"](window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/") } else if (typeof location !== "undefined") { PACKAGE_PATH = encodeURIComponent(location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/") } else { throw "using preloaded data can only be done on a web page or in a web worker" } var PACKAGE_NAME = "./worker/mecab.data"; var REMOTE_PACKAGE_BASE = mecabDataPath; if (typeof Module["locateFilePackage"] === "function" && !Module["locateFile"]) { Module["locateFile"] = Module["locateFilePackage"]; err("warning: you defined Module.locateFilePackage, that has been renamed to Module.locateFile (using your locateFilePackage for now)") } var REMOTE_PACKAGE_NAME = Module["locateFile"] ? Module["locateFile"](REMOTE_PACKAGE_BASE, "") : REMOTE_PACKAGE_BASE; var REMOTE_PACKAGE_SIZE = metadata["remote_package_size"]; var PACKAGE_UUID = metadata["package_uuid"]; function fetchRemotePackage(packageName, packageSize, callback, errback) { var xhr = new XMLHttpRequest; xhr.open("GET", packageName, true); xhr.responseType = "arraybuffer"; xhr.onprogress = function (event) { var url = packageName; var size = packageSize; if (event.total) size = event.total; if (event.loaded) { if (!xhr.addedTotal) { xhr.addedTotal = true; if (!Module.dataFileDownloads) Module.dataFileDownloads = {}; Module.dataFileDownloads[url] = { loaded: event.loaded, total: size } } else { Module.dataFileDownloads[url].loaded = event.loaded } var total = 0; var loaded = 0; var num = 0; for (var download in Module.dataFileDownloads) { var data = Module.dataFileDownloads[download]; total += data.total; loaded += data.loaded; num++ } total = Math.ceil(total * Module.expectedDataFileDownloads / num); if (Module["setStatus"]) Module["setStatus"]("Downloading data... (" + loaded + "/" + total + ")") } else if (!Module.dataFileDownloads) { if (Module["setStatus"]) Module["setStatus"]("Downloading data...") } }; xhr.onerror = function (event) { throw new Error("NetworkError for: " + packageName) }; xhr.onload = function (event) { if (xhr.status == 200 || xhr.status == 304 || xhr.status == 206 || xhr.status == 0 && xhr.response) { var packageData = xhr.response; callback(packageData) } else { throw new Error(xhr.statusText + " : " + xhr.responseURL) } }; xhr.send(null) } function handleError(error) { console.error("package error:", error) } var fetchedCallback = null; var fetched = Module["getPreloadedPackage"] ? Module["getPreloadedPackage"](REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE) : null; if (!fetched) fetchRemotePackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE, function (data) { if (fetchedCallback) { fetchedCallback(data); fetchedCallback = null } else { fetched = data } }, handleError); function runWithFS() { function assert(check, msg) { if (!check) throw msg + (new Error).stack } Module["FS_createPath"]("/", "unidic", true, true); function DataRequest(start, end, audio) { this.start = start; this.end = end; this.audio = audio } DataRequest.prototype = { requests: {}, open: function (mode, name) { this.name = name; this.requests[name] = this; Module["addRunDependency"]("fp " + this.name) }, send: function () { }, onload: function () { var byteArray = this.byteArray.subarray(this.start, this.end); this.finish(byteArray) }, finish: function (byteArray) { var that = this; Module["FS_createDataFile"](this.name, null, byteArray, true, true, true); Module["removeRunDependency"]("fp " + that.name); this.requests[this.name] = null } }; var files = metadata["files"]; for (var i = 0; i < files.length; ++i) { new DataRequest(files[i]["start"], files[i]["end"], files[i]["audio"]).open("GET", files[i]["filename"]) } function processPackageData(arrayBuffer) { Module.finishedDataFileDownloads++; assert(arrayBuffer, "Loading data file failed."); assert(arrayBuffer instanceof ArrayBuffer, "bad input to processPackageData"); var byteArray = new Uint8Array(arrayBuffer); DataRequest.prototype.byteArray = byteArray; var files = metadata["files"]; for (var i = 0; i < files.length; ++i) { DataRequest.prototype.requests[files[i].filename].onload() } Module["removeRunDependency"]("datafile_./worker/mecab.data") } Module["addRunDependency"]("datafile_./worker/mecab.data"); if (!Module.preloadResults) Module.preloadResults = {}; Module.preloadResults[PACKAGE_NAME] = { fromCache: false }; if (fetched) { processPackageData(fetched); fetched = null } else { fetchedCallback = processPackageData } } if (Module["calledRun"]) { runWithFS() } else { if (!Module["preRun"]) Module["preRun"] = []; Module["preRun"].push(runWithFS) } }; loadPackage({ "files": [{ "filename": "/mecabrc", "start": 0, "end": 295, "audio": 0 }, { "filename": "/unidic/matrix.bin", "start": 295, "end": 71545021, "audio": 0 }, { "filename": "/unidic/unk.dic", "start": 71545021, "end": 71550513, "audio": 0 }, { "filename": "/unidic/sys.dic", "start": 71550513, "end": 205413622, "audio": 0 }, { "filename": "/unidic/dicrc", "start": 205413622, "end": 205414526, "audio": 0 }, { "filename": "/unidic/char.bin", "start": 205414526, "end": 205677022, "audio": 0 }], "remote_package_size": 205677022, "package_uuid": "328ccd66-df46-4aab-9b20-54444e049709" }) })(); var moduleOverrides = {}; var key; for (key in Module) { if (Module.hasOwnProperty(key)) { moduleOverrides[key] = Module[key] } } var arguments_ = []; var thisProgram = "./this.program"; var quit_ = function (status, toThrow) { throw toThrow }; var ENVIRONMENT_IS_WEB = false; var ENVIRONMENT_IS_WORKER = true; var scriptDirectory = ""; function locateFile(path) { if (Module["locateFile"]) { return Module["locateFile"](path, scriptDirectory) } return scriptDirectory + path } var read_, readAsync, readBinary, setWindowTitle; if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) { if (ENVIRONMENT_IS_WORKER) { scriptDirectory = self.location.href } else if (document.currentScript) { scriptDirectory = document.currentScript.src } if (_scriptDir) { scriptDirectory = _scriptDir } if (scriptDirectory.indexOf("blob:") !== 0) { scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1) } else { scriptDirectory = "" } { read_ = function shell_read(url) { var xhr = new XMLHttpRequest; xhr.open("GET", url, false); xhr.send(null); return xhr.responseText }; if (ENVIRONMENT_IS_WORKER) { readBinary = function readBinary(url) { var xhr = new XMLHttpRequest; xhr.open("GET", url, false); xhr.responseType = "arraybuffer"; xhr.send(null); return new Uint8Array(xhr.response) } } readAsync = function readAsync(url, onload, onerror) { var xhr = new XMLHttpRequest; xhr.open("GET", url, true); xhr.responseType = "arraybuffer"; xhr.onload = function xhr_onload() { if (xhr.status == 200 || xhr.status == 0 && xhr.response) { onload(xhr.response); return } onerror() }; xhr.onerror = onerror; xhr.send(null) } } setWindowTitle = function (title) { document.title = title } } else { } for (key in moduleOverrides) { if (moduleOverrides.hasOwnProperty(key)) { Module[key] = moduleOverrides[key] } } moduleOverrides = null; if (Module["arguments"]) arguments_ = Module["arguments"]; if (Module["thisProgram"]) thisProgram = Module["thisProgram"]; if (Module["quit"]) quit_ = Module["quit"]; function dynamicAlloc(size) { var ret = HEAP32[DYNAMICTOP_PTR >> 2]; var end = ret + size + 15 & -16; HEAP32[DYNAMICTOP_PTR >> 2] = end; return ret } function warnOnce(text) { if (!warnOnce.shown) warnOnce.shown = {}; if (!warnOnce.shown[text]) { warnOnce.shown[text] = 1; err(text) } } var wasmBinary; if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"]; var noExitRuntime; if (Module["noExitRuntime"]) noExitRuntime = Module["noExitRuntime"]; if (typeof WebAssembly !== "object") { err("no native wasm support detected") } var wasmMemory; var wasmTable = new WebAssembly.Table({ "initial": 546, "maximum": 546 + 0, "element": "anyfunc" }); var ABORT = false; var EXITSTATUS = 0; function assert(condition, text) { if (!condition) { abort("Assertion failed: " + text) } } function getCFunc(ident) { var func = Module["_" + ident]; assert(func, "Cannot call unknown function " + ident + ", make sure it is exported"); return func } function ccall(ident, returnType, argTypes, args, opts) { var toC = { "string": function (str) { var ret = 0; if (str !== null && str !== undefined && str !== 0) { var len = (str.length << 2) + 1; ret = stackAlloc(len); stringToUTF8(str, ret, len) } return ret }, "array": function (arr) { var ret = stackAlloc(arr.length); writeArrayToMemory(arr, ret); return ret } }; function convertReturnValue(ret) { if (returnType === "string") return UTF8ToString(ret); if (returnType === "boolean") return Boolean(ret); return ret } var func = getCFunc(ident); var cArgs = []; var stack = 0; if (args) { for (var i = 0; i < args.length; i++) { var converter = toC[argTypes[i]]; if (converter) { if (stack === 0) stack = stackSave(); cArgs[i] = converter(args[i]) } else { cArgs[i] = args[i] } } } var ret = func.apply(null, cArgs); ret = convertReturnValue(ret); if (stack !== 0) stackRestore(stack); return ret } function cwrap(ident, returnType, argTypes, opts) { argTypes = argTypes || []; var numericArgs = argTypes.every(function (type) { return type === "number" }); var numericRet = returnType !== "string"; if (numericRet && numericArgs && !opts) { return getCFunc(ident) } return function () { return ccall(ident, returnType, argTypes, arguments, opts) } } function getMemory(size) { if (!runtimeInitialized) return dynamicAlloc(size); return _malloc(size) } var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined; function UTF8ArrayToString(heap, idx, maxBytesToRead) { var endIdx = idx + maxBytesToRead; var endPtr = idx; while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr; if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) { return UTF8Decoder.decode(heap.subarray(idx, endPtr)) } else { var str = ""; while (idx < endPtr) { var u0 = heap[idx++]; if (!(u0 & 128)) { str += String.fromCharCode(u0); continue } var u1 = heap[idx++] & 63; if ((u0 & 224) == 192) { str += String.fromCharCode((u0 & 31) << 6 | u1); continue } var u2 = heap[idx++] & 63; if ((u0 & 240) == 224) { u0 = (u0 & 15) << 12 | u1 << 6 | u2 } else { u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63 } if (u0 < 65536) { str += String.fromCharCode(u0) } else { var ch = u0 - 65536; str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023) } } } return str } function UTF8ToString(ptr, maxBytesToRead) { return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "" } function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) { if (!(maxBytesToWrite > 0)) return 0; var startIdx = outIdx; var endIdx = outIdx + maxBytesToWrite - 1; for (var i = 0; i < str.length; ++i) { var u = str.charCodeAt(i); if (u >= 55296 && u <= 57343) { var u1 = str.charCodeAt(++i); u = 65536 + ((u & 1023) << 10) | u1 & 1023 } if (u <= 127) { if (outIdx >= endIdx) break; heap[outIdx++] = u } else if (u <= 2047) { if (outIdx + 1 >= endIdx) break; heap[outIdx++] = 192 | u >> 6; heap[outIdx++] = 128 | u & 63 } else if (u <= 65535) { if (outIdx + 2 >= endIdx) break; heap[outIdx++] = 224 | u >> 12; heap[outIdx++] = 128 | u >> 6 & 63; heap[outIdx++] = 128 | u & 63 } else { if (outIdx + 3 >= endIdx) break; heap[outIdx++] = 240 | u >> 18; heap[outIdx++] = 128 | u >> 12 & 63; heap[outIdx++] = 128 | u >> 6 & 63; heap[outIdx++] = 128 | u & 63 } } heap[outIdx] = 0; return outIdx - startIdx } function stringToUTF8(str, outPtr, maxBytesToWrite) { return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite) } function lengthBytesUTF8(str) { var len = 0; for (var i = 0; i < str.length; ++i) { var u = str.charCodeAt(i); if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023; if (u <= 127) ++len; else if (u <= 2047) len += 2; else if (u <= 65535) len += 3; else len += 4 } return len } var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : undefined; function writeArrayToMemory(array, buffer) { HEAP8.set(array, buffer) } function writeAsciiToMemory(str, buffer, dontAddNull) { for (var i = 0; i < str.length; ++i) { HEAP8[buffer++ >> 0] = str.charCodeAt(i) } if (!dontAddNull) HEAP8[buffer >> 0] = 0 } var WASM_PAGE_SIZE = 65536; function alignUp(x, multiple) { if (x % multiple > 0) { x += multiple - x % multiple } return x } var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64; function updateGlobalBufferAndViews(buf) { buffer = buf; Module["HEAP8"] = HEAP8 = new Int8Array(buf); Module["HEAP16"] = HEAP16 = new Int16Array(buf); Module["HEAP32"] = HEAP32 = new Int32Array(buf); Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf); Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf); Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf); Module["HEAPF32"] = HEAPF32 = new Float32Array(buf); Module["HEAPF64"] = HEAPF64 = new Float64Array(buf) } var DYNAMIC_BASE = 6477088, DYNAMICTOP_PTR = 1234048; var INITIAL_INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216; if (Module["wasmMemory"]) { wasmMemory = Module["wasmMemory"] } else { wasmMemory = new WebAssembly.Memory({ "initial": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE, "maximum": 2147483648 / WASM_PAGE_SIZE }) } if (wasmMemory) { buffer = wasmMemory.buffer } INITIAL_INITIAL_MEMORY = buffer.byteLength; updateGlobalBufferAndViews(buffer); HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE; function callRuntimeCallbacks(callbacks) { while (callbacks.length > 0) { var callback = callbacks.shift(); if (typeof callback == "function") { callback(Module); continue } var func = callback.func; if (typeof func === "number") { if (callback.arg === undefined) { Module["dynCall_v"](func) } else { Module["dynCall_vi"](func, callback.arg) } } else { func(callback.arg === undefined ? null : callback.arg) } } } var __ATPRERUN__ = []; var __ATINIT__ = []; var __ATMAIN__ = []; var __ATPOSTRUN__ = []; var runtimeInitialized = false; var runtimeExited = false; function preRun() { if (Module["preRun"]) { if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]]; while (Module["preRun"].length) { addOnPreRun(Module["preRun"].shift()) } } callRuntimeCallbacks(__ATPRERUN__) } function initRuntime() { runtimeInitialized = true; if (!Module["noFSInit"] && !FS.init.initialized) FS.init(); TTY.init(); callRuntimeCallbacks(__ATINIT__) } function preMain() { FS.ignorePermissions = false; callRuntimeCallbacks(__ATMAIN__) } function exitRuntime() { runtimeExited = true } function postRun() { if (Module["postRun"]) { if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]]; while (Module["postRun"].length) { addOnPostRun(Module["postRun"].shift()) } } callRuntimeCallbacks(__ATPOSTRUN__) } function addOnPreRun(cb) { __ATPRERUN__.unshift(cb) } function addOnPostRun(cb) { __ATPOSTRUN__.unshift(cb) } var Math_abs = Math.abs; var Math_ceil = Math.ceil; var Math_floor = Math.floor; var Math_min = Math.min; var runDependencies = 0; var runDependencyWatcher = null; var dependenciesFulfilled = null; function getUniqueRunDependency(id) { return id } function addRunDependency(id) { runDependencies++; if (Module["monitorRunDependencies"]) { Module["monitorRunDependencies"](runDependencies) } } function removeRunDependency(id) { runDependencies--; if (Module["monitorRunDependencies"]) { Module["monitorRunDependencies"](runDependencies) } if (runDependencies == 0) { if (runDependencyWatcher !== null) { clearInterval(runDependencyWatcher); runDependencyWatcher = null } if (dependenciesFulfilled) { var callback = dependenciesFulfilled; dependenciesFulfilled = null; callback() } } } Module["preloadedImages"] = {}; Module["preloadedAudios"] = {}; function abort(what) { if (Module["onAbort"]) { Module["onAbort"](what) } what += ""; out(what); err(what); ABORT = true; EXITSTATUS = 1; what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info."; throw new WebAssembly.RuntimeError(what) } function hasPrefix(str, prefix) { return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0 } var dataURIPrefix = "data:application/octet-stream;base64,"; function isDataURI(filename) { return hasPrefix(filename, dataURIPrefix) } var wasmBinaryFile = mecabWasmPath; if (!isDataURI(wasmBinaryFile)) { wasmBinaryFile = locateFile(wasmBinaryFile) } function getBinary() { try { if (wasmBinary) { return new Uint8Array(wasmBinary) } if (readBinary) { return readBinary(wasmBinaryFile) } else { throw "both async and sync fetching of the wasm failed" } } catch (err) { abort(err) } } function getBinaryPromise() { if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function") { return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function (response) { if (!response["ok"]) { throw "failed to load wasm binary file at '" + wasmBinaryFile + "'" } return response["arrayBuffer"]() }).catch(function () { return getBinary() }) } return new Promise(function (resolve, reject) { resolve(getBinary()) }) } function createWasm() { var info = { "a": asmLibraryArg }; function receiveInstance(instance, module) { var exports = instance.exports; Module["asm"] = exports; removeRunDependency("wasm-instantiate") } addRunDependency("wasm-instantiate"); function receiveInstantiatedSource(output) { receiveInstance(output["instance"]) } function instantiateArrayBuffer(receiver) { return getBinaryPromise().then(function (binary) { return WebAssembly.instantiate(binary, info) }).then(receiver, function (reason) { err("failed to asynchronously prepare wasm: " + reason); abort(reason) }) } function instantiateAsync() { if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && typeof fetch === "function") { fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function (response) { var result = WebAssembly.instantiateStreaming(response, info); return result.then(receiveInstantiatedSource, function (reason) { err("wasm streaming compile failed: " + reason); err("falling back to ArrayBuffer instantiation"); instantiateArrayBuffer(receiveInstantiatedSource) }) }) } else { return instantiateArrayBuffer(receiveInstantiatedSource) } } if (Module["instantiateWasm"]) { try { var exports = Module["instantiateWasm"](info, receiveInstance); return exports } catch (e) { err("Module.instantiateWasm callback failed with error: " + e); return false } } instantiateAsync(); return {} } var tempDouble; var tempI64; __ATINIT__.push({ func: function () { ___wasm_call_ctors() } }); function demangle(func) { return func } function demangleAll(text) { var regex = /\b_Z[\w\d_]+/g; return text.replace(regex, function (x) { var y = demangle(x); return x === y ? x : y + " [" + x + "]" }) } function jsStackTrace() { var err = new Error; if (!err.stack) { try { throw new Error } catch (e) { err = e } if (!err.stack) { return "(no stack trace available)" } } return err.stack.toString() } function stackTrace() { var js = jsStackTrace(); if (Module["extraStackTrace"]) js += "\n" + Module["extraStackTrace"](); return demangleAll(js) } function ___cxa_allocate_exception(size) { return _malloc(size) } var ___exception_infos = {}; var ___exception_last = 0; function __ZSt18uncaught_exceptionv() { return __ZSt18uncaught_exceptionv.uncaught_exceptions > 0 } function ___cxa_throw(ptr, type, destructor) { ___exception_infos[ptr] = { ptr: ptr, adjusted: [ptr], type: type, destructor: destructor, refcount: 0, caught: false, rethrown: false }; ___exception_last = ptr; if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) { __ZSt18uncaught_exceptionv.uncaught_exceptions = 1 } else { __ZSt18uncaught_exceptionv.uncaught_exceptions++ } throw ptr } function setErrNo(value) { HEAP32[___errno_location() >> 2] = value; return value } function ___map_file(pathname, size) { setErrNo(63); return -1 } var PATH = { splitPath: function (filename) { var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/; return splitPathRe.exec(filename).slice(1) }, normalizeArray: function (parts, allowAboveRoot) { var up = 0; for (var i = parts.length - 1; i >= 0; i--) { var last = parts[i]; if (last === ".") { parts.splice(i, 1) } else if (last === "..") { parts.splice(i, 1); up++ } else if (up) { parts.splice(i, 1); up-- } } if (allowAboveRoot) { for (; up; up--) { parts.unshift("..") } } return parts }, normalize: function (path) { var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/"; path = PATH.normalizeArray(path.split("/").filter(function (p) { return !!p }), !isAbsolute).join("/"); if (!path && !isAbsolute) { path = "." } if (path && trailingSlash) { path += "/" } return (isAbsolute ? "/" : "") + path }, dirname: function (path) { var result = PATH.splitPath(path), root = result[0], dir = result[1]; if (!root && !dir) { return "." } if (dir) { dir = dir.substr(0, dir.length - 1) } return root + dir }, basename: function (path) { if (path === "/") return "/"; var lastSlash = path.lastIndexOf("/"); if (lastSlash === -1) return path; return path.substr(lastSlash + 1) }, extname: function (path) { return PATH.splitPath(path)[3] }, join: function () { var paths = Array.prototype.slice.call(arguments, 0); return PATH.normalize(paths.join("/")) }, join2: function (l, r) { return PATH.normalize(l + "/" + r) } }; var PATH_FS = { resolve: function () { var resolvedPath = "", resolvedAbsolute = false; for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) { var path = i >= 0 ? arguments[i] : FS.cwd(); if (typeof path !== "string") { throw new TypeError("Arguments to path.resolve must be strings") } else if (!path) { return "" } resolvedPath = path + "/" + resolvedPath; resolvedAbsolute = path.charAt(0) === "/" } resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function (p) { return !!p }), !resolvedAbsolute).join("/"); return (resolvedAbsolute ? "/" : "") + resolvedPath || "." }, relative: function (from, to) { from = PATH_FS.resolve(from).substr(1); to = PATH_FS.resolve(to).substr(1); function trim(arr) { var start = 0; for (; start < arr.length; start++) { if (arr[start] !== "") break } var end = arr.length - 1; for (; end >= 0; end--) { if (arr[end] !== "") break } if (start > end) return []; return arr.slice(start, end - start + 1) } var fromParts = trim(from.split("/")); var toParts = trim(to.split("/")); var length = Math.min(fromParts.length, toParts.length); var samePartsLength = length; for (var i = 0; i < length; i++) { if (fromParts[i] !== toParts[i]) { samePartsLength = i; break } } var outputParts = []; for (var i = samePartsLength; i < fromParts.length; i++) { outputParts.push("..") } outputParts = outputParts.concat(toParts.slice(samePartsLength)); return outputParts.join("/") } }; var TTY = { ttys: [], init: function () { }, shutdown: function () { }, register: function (dev, ops) { TTY.ttys[dev] = { input: [], output: [], ops: ops }; FS.registerDevice(dev, TTY.stream_ops) }, stream_ops: { open: function (stream) { var tty = TTY.ttys[stream.node.rdev]; if (!tty) { throw new FS.ErrnoError(43) } stream.tty = tty; stream.seekable = false }, close: function (stream) { stream.tty.ops.flush(stream.tty) }, flush: function (stream) { stream.tty.ops.flush(stream.tty) }, read: function (stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.get_char) { throw new FS.ErrnoError(60) } var bytesRead = 0; for (var i = 0; i < length; i++) { var result; try { result = stream.tty.ops.get_char(stream.tty) } catch (e) { throw new FS.ErrnoError(29) } if (result === undefined && bytesRead === 0) { throw new FS.ErrnoError(6) } if (result === null || result === undefined) break; bytesRead++; buffer[offset + i] = result } if (bytesRead) { stream.node.timestamp = Date.now() } return bytesRead }, write: function (stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.put_char) { throw new FS.ErrnoError(60) } try { for (var i = 0; i < length; i++) { stream.tty.ops.put_char(stream.tty, buffer[offset + i]) } } catch (e) { throw new FS.ErrnoError(29) } if (length) { stream.node.timestamp = Date.now() } return i } }, default_tty_ops: { get_char: function (tty) { if (!tty.input.length) { var result = null; if (typeof window != "undefined" && typeof window.prompt == "function") { result = window.prompt("Input: "); if (result !== null) { result += "\n" } } else if (typeof readline == "function") { result = readline(); if (result !== null) { result += "\n" } } if (!result) { return null } tty.input = intArrayFromString(result, true) } return tty.input.shift() }, put_char: function (tty, val) { if (val === null || val === 10) { out(UTF8ArrayToString(tty.output, 0)); tty.output = [] } else { if (val != 0) tty.output.push(val) } }, flush: function (tty) { if (tty.output && tty.output.length > 0) { out(UTF8ArrayToString(tty.output, 0)); tty.output = [] } } }, default_tty1_ops: { put_char: function (tty, val) { if (val === null || val === 10) { err(UTF8ArrayToString(tty.output, 0)); tty.output = [] } else { if (val != 0) tty.output.push(val) } }, flush: function (tty) { if (tty.output && tty.output.length > 0) { err(UTF8ArrayToString(tty.output, 0)); tty.output = [] } } } }; var MEMFS = { ops_table: null, mount: function (mount) { return MEMFS.createNode(null, "/", 16384 | 511, 0) }, createNode: function (parent, name, mode, dev) { if (FS.isBlkdev(mode) || FS.isFIFO(mode)) { throw new FS.ErrnoError(63) } if (!MEMFS.ops_table) { MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } } } var node = FS.createNode(parent, name, mode, dev); if (FS.isDir(node.mode)) { node.node_ops = MEMFS.ops_table.dir.node; node.stream_ops = MEMFS.ops_table.dir.stream; node.contents = {} } else if (FS.isFile(node.mode)) { node.node_ops = MEMFS.ops_table.file.node; node.stream_ops = MEMFS.ops_table.file.stream; node.usedBytes = 0; node.contents = null } else if (FS.isLink(node.mode)) { node.node_ops = MEMFS.ops_table.link.node; node.stream_ops = MEMFS.ops_table.link.stream } else if (FS.isChrdev(node.mode)) { node.node_ops = MEMFS.ops_table.chrdev.node; node.stream_ops = MEMFS.ops_table.chrdev.stream } node.timestamp = Date.now(); if (parent) { parent.contents[name] = node } return node }, getFileDataAsRegularArray: function (node) { if (node.contents && node.contents.subarray) { var arr = []; for (var i = 0; i < node.usedBytes; ++i)arr.push(node.contents[i]); return arr } return node.contents }, getFileDataAsTypedArray: function (node) { if (!node.contents) return new Uint8Array(0); if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); return new Uint8Array(node.contents) }, expandFileStorage: function (node, newCapacity) { var prevCapacity = node.contents ? node.contents.length : 0; if (prevCapacity >= newCapacity) return; var CAPACITY_DOUBLING_MAX = 1024 * 1024; newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0); if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); var oldContents = node.contents; node.contents = new Uint8Array(newCapacity); if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); return }, resizeFileStorage: function (node, newSize) { if (node.usedBytes == newSize) return; if (newSize == 0) { node.contents = null; node.usedBytes = 0; return } if (!node.contents || node.contents.subarray) { var oldContents = node.contents; node.contents = new Uint8Array(newSize); if (oldContents) { node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))) } node.usedBytes = newSize; return } if (!node.contents) node.contents = []; if (node.contents.length > newSize) node.contents.length = newSize; else while (node.contents.length < newSize) node.contents.push(0); node.usedBytes = newSize }, node_ops: { getattr: function (node) { var attr = {}; attr.dev = FS.isChrdev(node.mode) ? node.id : 1; attr.ino = node.id; attr.mode = node.mode; attr.nlink = 1; attr.uid = 0; attr.gid = 0; attr.rdev = node.rdev; if (FS.isDir(node.mode)) { attr.size = 4096 } else if (FS.isFile(node.mode)) { attr.size = node.usedBytes } else if (FS.isLink(node.mode)) { attr.size = node.link.length } else { attr.size = 0 } attr.atime = new Date(node.timestamp); attr.mtime = new Date(node.timestamp); attr.ctime = new Date(node.timestamp); attr.blksize = 4096; attr.blocks = Math.ceil(attr.size / attr.blksize); return attr }, setattr: function (node, attr) { if (attr.mode !== undefined) { node.mode = attr.mode } if (attr.timestamp !== undefined) { node.timestamp = attr.timestamp } if (attr.size !== undefined) { MEMFS.resizeFileStorage(node, attr.size) } }, lookup: function (parent, name) { throw FS.genericErrors[44] }, mknod: function (parent, name, mode, dev) { return MEMFS.createNode(parent, name, mode, dev) }, rename: function (old_node, new_dir, new_name) { if (FS.isDir(old_node.mode)) { var new_node; try { new_node = FS.lookupNode(new_dir, new_name) } catch (e) { } if (new_node) { for (var i in new_node.contents) { throw new FS.ErrnoError(55) } } } delete old_node.parent.contents[old_node.name]; old_node.name = new_name; new_dir.contents[new_name] = old_node; old_node.parent = new_dir }, unlink: function (parent, name) { delete parent.contents[name] }, rmdir: function (parent, name) { var node = FS.lookupNode(parent, name); for (var i in node.contents) { throw new FS.ErrnoError(55) } delete parent.contents[name] }, readdir: function (node) { var entries = [".", ".."]; for (var key in node.contents) { if (!node.contents.hasOwnProperty(key)) { continue } entries.push(key) } return entries }, symlink: function (parent, newname, oldpath) { var node = MEMFS.createNode(parent, newname, 511 | 40960, 0); node.link = oldpath; return node }, readlink: function (node) { if (!FS.isLink(node.mode)) { throw new FS.ErrnoError(28) } return node.link } }, stream_ops: { read: function (stream, buffer, offset, length, position) { var contents = stream.node.contents; if (position >= stream.node.usedBytes) return 0; var size = Math.min(stream.node.usedBytes - position, length); if (size > 8 && contents.subarray) { buffer.set(contents.subarray(position, position + size), offset) } else { for (var i = 0; i < size; i++)buffer[offset + i] = contents[position + i] } return size }, write: function (stream, buffer, offset, length, position, canOwn) { if (buffer.buffer === HEAP8.buffer) { canOwn = false } if (!length) return 0; var node = stream.node; node.timestamp = Date.now(); if (buffer.subarray && (!node.contents || node.contents.subarray)) { if (canOwn) { node.contents = buffer.subarray(offset, offset + length); node.usedBytes = length; return length } else if (node.usedBytes === 0 && position === 0) { node.contents = buffer.slice(offset, offset + length); node.usedBytes = length; return length } else if (position + length <= node.usedBytes) { node.contents.set(buffer.subarray(offset, offset + length), position); return length } } MEMFS.expandFileStorage(node, position + length); if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); else { for (var i = 0; i < length; i++) { node.contents[position + i] = buffer[offset + i] } } node.usedBytes = Math.max(node.usedBytes, position + length); return length }, llseek: function (stream, offset, whence) { var position = offset; if (whence === 1) { position += stream.position } else if (whence === 2) { if (FS.isFile(stream.node.mode)) { position += stream.node.usedBytes } } if (position < 0) { throw new FS.ErrnoError(28) } return position }, allocate: function (stream, offset, length) { MEMFS.expandFileStorage(stream.node, offset + length); stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length) }, mmap: function (stream, buffer, offset, length, position, prot, flags) { if (!FS.isFile(stream.node.mode)) { throw new FS.ErrnoError(43) } var ptr; var allocated; var contents = stream.node.contents; if (!(flags & 2) && contents.buffer === buffer.buffer) { allocated = false; ptr = contents.byteOffset } else { if (position > 0 || position + length < contents.length) { if (contents.subarray) { contents = contents.subarray(position, position + length) } else { contents = Array.prototype.slice.call(contents, position, position + length) } } allocated = true; var fromHeap = buffer.buffer == HEAP8.buffer; ptr = _malloc(length); if (!ptr) { throw new FS.ErrnoError(48) } (fromHeap ? HEAP8 : buffer).set(contents, ptr) } return { ptr: ptr, allocated: allocated } }, msync: function (stream, buffer, offset, length, mmapFlags) { if (!FS.isFile(stream.node.mode)) { throw new FS.ErrnoError(43) } if (mmapFlags & 2) { return 0 } var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false); return 0 } } }; var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, handleFSError: function (e) { if (!(e instanceof FS.ErrnoError)) throw e + " : " + stackTrace(); return setErrNo(e.errno) }, lookupPath: function (path, opts) { path = PATH_FS.resolve(FS.cwd(), path); opts = opts || {}; if (!path) return { path: "", node: null }; var defaults = { follow_mount: true, recurse_count: 0 }; for (var key in defaults) { if (opts[key] === undefined) { opts[key] = defaults[key] } } if (opts.recurse_count > 8) { throw new FS.ErrnoError(32) } var parts = PATH.normalizeArray(path.split("/").filter(function (p) { return !!p }), false); var current = FS.root; var current_path = "/"; for (var i = 0; i < parts.length; i++) { var islast = i === parts.length - 1; if (islast && opts.parent) { break } current = FS.lookupNode(current, parts[i]); current_path = PATH.join2(current_path, parts[i]); if (FS.isMountpoint(current)) { if (!islast || islast && opts.follow_mount) { current = current.mounted.root } } if (!islast || opts.follow) { var count = 0; while (FS.isLink(current.mode)) { var link = FS.readlink(current_path); current_path = PATH_FS.resolve(PATH.dirname(current_path), link); var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count }); current = lookup.node; if (count++ > 40) { throw new FS.ErrnoError(32) } } } } return { path: current_path, node: current } }, getPath: function (node) { var path; while (true) { if (FS.isRoot(node)) { var mount = node.mount.mountpoint; if (!path) return mount; return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path } path = path ? node.name + "/" + path : node.name; node = node.parent } }, hashName: function (parentid, name) { var hash = 0; for (var i = 0; i < name.length; i++) { hash = (hash << 5) - hash + name.charCodeAt(i) | 0 } return (parentid + hash >>> 0) % FS.nameTable.length }, hashAddNode: function (node) { var hash = FS.hashName(node.parent.id, node.name); node.name_next = FS.nameTable[hash]; FS.nameTable[hash] = node }, hashRemoveNode: function (node) { var hash = FS.hashName(node.parent.id, node.name); if (FS.nameTable[hash] === node) { FS.nameTable[hash] = node.name_next } else { var current = FS.nameTable[hash]; while (current) { if (current.name_next === node) { current.name_next = node.name_next; break } current = current.name_next } } }, lookupNode: function (parent, name) { var errCode = FS.mayLookup(parent); if (errCode) { throw new FS.ErrnoError(errCode, parent) } var hash = FS.hashName(parent.id, name); for (var node = FS.nameTable[hash]; node; node = node.name_next) { var nodeName = node.name; if (node.parent.id === parent.id && nodeName === name) { return node } } return FS.lookup(parent, name) }, createNode: function (parent, name, mode, rdev) { var node = new FS.FSNode(parent, name, mode, rdev); FS.hashAddNode(node); return node }, destroyNode: function (node) { FS.hashRemoveNode(node) }, isRoot: function (node) { return node === node.parent }, isMountpoint: function (node) { return !!node.mounted }, isFile: function (mode) { return (mode & 61440) === 32768 }, isDir: function (mode) { return (mode & 61440) === 16384 }, isLink: function (mode) { return (mode & 61440) === 40960 }, isChrdev: function (mode) { return (mode & 61440) === 8192 }, isBlkdev: function (mode) { return (mode & 61440) === 24576 }, isFIFO: function (mode) { return (mode & 61440) === 4096 }, isSocket: function (mode) { return (mode & 49152) === 49152 }, flagModes: { "r": 0, "rs": 1052672, "r+": 2, "w": 577, "wx": 705, "xw": 705, "w+": 578, "wx+": 706, "xw+": 706, "a": 1089, "ax": 1217, "xa": 1217, "a+": 1090, "ax+": 1218, "xa+": 1218 }, modeStringToFlags: function (str) { var flags = FS.flagModes[str]; if (typeof flags === "undefined") { throw new Error("Unknown file open mode: " + str) } return flags }, flagsToPermissionString: function (flag) { var perms = ["r", "w", "rw"][flag & 3]; if (flag & 512) { perms += "w" } return perms }, nodePermissions: function (node, perms) { if (FS.ignorePermissions) { return 0 } if (perms.indexOf("r") !== -1 && !(node.mode & 292)) { return 2 } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) { return 2 } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) { return 2 } return 0 }, mayLookup: function (dir) { var errCode = FS.nodePermissions(dir, "x"); if (errCode) return errCode; if (!dir.node_ops.lookup) return 2; return 0 }, mayCreate: function (dir, name) { try { var node = FS.lookupNode(dir, name); return 20 } catch (e) { } return FS.nodePermissions(dir, "wx") }, mayDelete: function (dir, name, isdir) { var node; try { node = FS.lookupNode(dir, name) } catch (e) { return e.errno } var errCode = FS.nodePermissions(dir, "wx"); if (errCode) { return errCode } if (isdir) { if (!FS.isDir(node.mode)) { return 54 } if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) { return 10 } } else { if (FS.isDir(node.mode)) { return 31 } } return 0 }, mayOpen: function (node, flags) { if (!node) { return 44 } if (FS.isLink(node.mode)) { return 32 } else if (FS.isDir(node.mode)) { if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) { return 31 } } return FS.nodePermissions(node, FS.flagsToPermissionString(flags)) }, MAX_OPEN_FDS: 4096, nextfd: function (fd_start, fd_end) { fd_start = fd_start || 0; fd_end = fd_end || FS.MAX_OPEN_FDS; for (var fd = fd_start; fd <= fd_end; fd++) { if (!FS.streams[fd]) { return fd } } throw new FS.ErrnoError(33) }, getStream: function (fd) { return FS.streams[fd] }, createStream: function (stream, fd_start, fd_end) { if (!FS.FSStream) { FS.FSStream = function () { }; FS.FSStream.prototype = { object: { get: function () { return this.node }, set: function (val) { this.node = val } }, isRead: { get: function () { return (this.flags & 2097155) !== 1 } }, isWrite: { get: function () { return (this.flags & 2097155) !== 0 } }, isAppend: { get: function () { return this.flags & 1024 } } } } var newStream = new FS.FSStream; for (var p in stream) { newStream[p] = stream[p] } stream = newStream; var fd = FS.nextfd(fd_start, fd_end); stream.fd = fd; FS.streams[fd] = stream; return stream }, closeStream: function (fd) { FS.streams[fd] = null }, chrdev_stream_ops: { open: function (stream) { var device = FS.getDevice(stream.node.rdev); stream.stream_ops = device.stream_ops; if (stream.stream_ops.open) { stream.stream_ops.open(stream) } }, llseek: function () { throw new FS.ErrnoError(70) } }, major: function (dev) { return dev >> 8 }, minor: function (dev) { return dev & 255 }, makedev: function (ma, mi) { return ma << 8 | mi }, registerDevice: function (dev, ops) { FS.devices[dev] = { stream_ops: ops } }, getDevice: function (dev) { return FS.devices[dev] }, getMounts: function (mount) { var mounts = []; var check = [mount]; while (check.length) { var m = check.pop(); mounts.push(m); check.push.apply(check, m.mounts) } return mounts }, syncfs: function (populate, callback) { if (typeof populate === "function") { callback = populate; populate = false } FS.syncFSRequests++; if (FS.syncFSRequests > 1) { err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work") } var mounts = FS.getMounts(FS.root.mount); var completed = 0; function doCallback(errCode) { FS.syncFSRequests--; return callback(errCode) } function done(errCode) { if (errCode) { if (!done.errored) { done.errored = true; return doCallback(errCode) } return } if (++completed >= mounts.length) { doCallback(null) } } mounts.forEach(function (mount) { if (!mount.type.syncfs) { return done(null) } mount.type.syncfs(mount, populate, done) }) }, mount: function (type, opts, mountpoint) { var root = mountpoint === "/"; var pseudo = !mountpoint; var node; if (root && FS.root) { throw new FS.ErrnoError(10) } else if (!root && !pseudo) { var lookup = FS.lookupPath(mountpoint, { follow_mount: false }); mountpoint = lookup.path; node = lookup.node; if (FS.isMountpoint(node)) { throw new FS.ErrnoError(10) } if (!FS.isDir(node.mode)) { throw new FS.ErrnoError(54) } } var mount = { type: type, opts: opts, mountpoint: mountpoint, mounts: [] }; var mountRoot = type.mount(mount); mountRoot.mount = mount; mount.root = mountRoot; if (root) { FS.root = mountRoot } else if (node) { node.mounted = mount; if (node.mount) { node.mount.mounts.push(mount) } } return mountRoot }, unmount: function (mountpoint) { var lookup = FS.lookupPath(mountpoint, { follow_mount: false }); if (!FS.isMountpoint(lookup.node)) { throw new FS.ErrnoError(28) } var node = lookup.node; var mount = node.mounted; var mounts = FS.getMounts(mount); Object.keys(FS.nameTable).forEach(function (hash) { var current = FS.nameTable[hash]; while (current) { var next = current.name_next; if (mounts.indexOf(current.mount) !== -1) { FS.destroyNode(current) } current = next } }); node.mounted = null; var idx = node.mount.mounts.indexOf(mount); node.mount.mounts.splice(idx, 1) }, lookup: function (parent, name) { return parent.node_ops.lookup(parent, name) }, mknod: function (path, mode, dev) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); if (!name || name === "." || name === "..") { throw new FS.ErrnoError(28) } var errCode = FS.mayCreate(parent, name); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.mknod) { throw new FS.ErrnoError(63) } return parent.node_ops.mknod(parent, name, mode, dev) }, create: function (path, mode) { mode = mode !== undefined ? mode : 438; mode &= 4095; mode |= 32768; return FS.mknod(path, mode, 0) }, mkdir: function (path, mode) { mode = mode !== undefined ? mode : 511; mode &= 511 | 512; mode |= 16384; return FS.mknod(path, mode, 0) }, mkdirTree: function (path, mode) { var dirs = path.split("/"); var d = ""; for (var i = 0; i < dirs.length; ++i) { if (!dirs[i]) continue; d += "/" + dirs[i]; try { FS.mkdir(d, mode) } catch (e) { if (e.errno != 20) throw e } } }, mkdev: function (path, mode, dev) { if (typeof dev === "undefined") { dev = mode; mode = 438 } mode |= 8192; return FS.mknod(path, mode, dev) }, symlink: function (oldpath, newpath) { if (!PATH_FS.resolve(oldpath)) { throw new FS.ErrnoError(44) } var lookup = FS.lookupPath(newpath, { parent: true }); var parent = lookup.node; if (!parent) { throw new FS.ErrnoError(44) } var newname = PATH.basename(newpath); var errCode = FS.mayCreate(parent, newname); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.symlink) { throw new FS.ErrnoError(63) } return parent.node_ops.symlink(parent, newname, oldpath) }, rename: function (old_path, new_path) { var old_dirname = PATH.dirname(old_path); var new_dirname = PATH.dirname(new_path); var old_name = PATH.basename(old_path); var new_name = PATH.basename(new_path); var lookup, old_dir, new_dir; try { lookup = FS.lookupPath(old_path, { parent: true }); old_dir = lookup.node; lookup = FS.lookupPath(new_path, { parent: true }); new_dir = lookup.node } catch (e) { throw new FS.ErrnoError(10) } if (!old_dir || !new_dir) throw new FS.ErrnoError(44); if (old_dir.mount !== new_dir.mount) { throw new FS.ErrnoError(75) } var old_node = FS.lookupNode(old_dir, old_name); var relative = PATH_FS.relative(old_path, new_dirname); if (relative.charAt(0) !== ".") { throw new FS.ErrnoError(28) } relative = PATH_FS.relative(new_path, old_dirname); if (relative.charAt(0) !== ".") { throw new FS.ErrnoError(55) } var new_node; try { new_node = FS.lookupNode(new_dir, new_name) } catch (e) { } if (old_node === new_node) { return } var isdir = FS.isDir(old_node.mode); var errCode = FS.mayDelete(old_dir, old_name, isdir); if (errCode) { throw new FS.ErrnoError(errCode) } errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name); if (errCode) { throw new FS.ErrnoError(errCode) } if (!old_dir.node_ops.rename) { throw new FS.ErrnoError(63) } if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) { throw new FS.ErrnoError(10) } if (new_dir !== old_dir) { errCode = FS.nodePermissions(old_dir, "w"); if (errCode) { throw new FS.ErrnoError(errCode) } } try { if (FS.trackingDelegate["willMovePath"]) { FS.trackingDelegate["willMovePath"](old_path, new_path) } } catch (e) { err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message) } FS.hashRemoveNode(old_node); try { old_dir.node_ops.rename(old_node, new_dir, new_name) } catch (e) { throw e } finally { FS.hashAddNode(old_node) } try { if (FS.trackingDelegate["onMovePath"]) FS.trackingDelegate["onMovePath"](old_path, new_path) } catch (e) { err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message) } }, rmdir: function (path) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); var node = FS.lookupNode(parent, name); var errCode = FS.mayDelete(parent, name, true); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.rmdir) { throw new FS.ErrnoError(63) } if (FS.isMountpoint(node)) { throw new FS.ErrnoError(10) } try { if (FS.trackingDelegate["willDeletePath"]) { FS.trackingDelegate["willDeletePath"](path) } } catch (e) { err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message) } parent.node_ops.rmdir(parent, name); FS.destroyNode(node); try { if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path) } catch (e) { err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message) } }, readdir: function (path) { var lookup = FS.lookupPath(path, { follow: true }); var node = lookup.node; if (!node.node_ops.readdir) { throw new FS.ErrnoError(54) } return node.node_ops.readdir(node) }, unlink: function (path) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); var node = FS.lookupNode(parent, name); var errCode = FS.mayDelete(parent, name, false); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.unlink) { throw new FS.ErrnoError(63) } if (FS.isMountpoint(node)) { throw new FS.ErrnoError(10) } try { if (FS.trackingDelegate["willDeletePath"]) { FS.trackingDelegate["willDeletePath"](path) } } catch (e) { err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message) } parent.node_ops.unlink(parent, name); FS.destroyNode(node); try { if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path) } catch (e) { err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message) } }, readlink: function (path) { var lookup = FS.lookupPath(path); var link = lookup.node; if (!link) { throw new FS.ErrnoError(44) } if (!link.node_ops.readlink) { throw new FS.ErrnoError(28) } return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link)) }, stat: function (path, dontFollow) { var lookup = FS.lookupPath(path, { follow: !dontFollow }); var node = lookup.node; if (!node) { throw new FS.ErrnoError(44) } if (!node.node_ops.getattr) { throw new FS.ErrnoError(63) } return node.node_ops.getattr(node) }, lstat: function (path) { return FS.stat(path, true) }, chmod: function (path, mode, dontFollow) { var node; if (typeof path === "string") { var lookup = FS.lookupPath(path, { follow: !dontFollow }); node = lookup.node } else { node = path } if (!node.node_ops.setattr) { throw new FS.ErrnoError(63) } node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() }) }, lchmod: function (path, mode) { FS.chmod(path, mode, true) }, fchmod: function (fd, mode) { var stream = FS.getStream(fd); if (!stream) { throw new FS.ErrnoError(8) } FS.chmod(stream.node, mode) }, chown: function (path, uid, gid, dontFollow) { var node; if (typeof path === "string") { var lookup = FS.lookupPath(path, { follow: !dontFollow }); node = lookup.node } else { node = path } if (!node.node_ops.setattr) { throw new FS.ErrnoError(63) } node.node_ops.setattr(node, { timestamp: Date.now() }) }, lchown: function (path, uid, gid) { FS.chown(path, uid, gid, true) }, fchown: function (fd, uid, gid) { var stream = FS.getStream(fd); if (!stream) { throw new FS.ErrnoError(8) } FS.chown(stream.node, uid, gid) }, truncate: function (path, len) { if (len < 0) { throw new FS.ErrnoError(28) } var node; if (typeof path === "string") { var lookup = FS.lookupPath(path, { follow: true }); node = lookup.node } else { node = path } if (!node.node_ops.setattr) { throw new FS.ErrnoError(63) } if (FS.isDir(node.mode)) { throw new FS.ErrnoError(31) } if (!FS.isFile(node.mode)) { throw new FS.ErrnoError(28) } var errCode = FS.nodePermissions(node, "w"); if (errCode) { throw new FS.ErrnoError(errCode) } node.node_ops.setattr(node, { size: len, timestamp: Date.now() }) }, ftruncate: function (fd, len) { var stream = FS.getStream(fd); if (!stream) { throw new FS.ErrnoError(8) } if ((stream.flags & 2097155) === 0) { throw new FS.ErrnoError(28) } FS.truncate(stream.node, len) }, utime: function (path, atime, mtime) { var lookup = FS.lookupPath(path, { follow: true }); var node = lookup.node; node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) }) }, open: function (path, flags, mode, fd_start, fd_end) { if (path === "") { throw new FS.ErrnoError(44) } flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags; mode = typeof mode === "undefined" ? 438 : mode; if (flags & 64) { mode = mode & 4095 | 32768 } else { mode = 0 } var node; if (typeof path === "object") { node = path } else { path = PATH.normalize(path); try { var lookup = FS.lookupPath(path, { follow: !(flags & 131072) }); node = lookup.node } catch (e) { } } var created = false; if (flags & 64) { if (node) { if (flags & 128) { throw new FS.ErrnoError(20) } } else { node = FS.mknod(path, mode, 0); created = true } } if (!node) { throw new FS.ErrnoError(44) } if (FS.isChrdev(node.mode)) { flags &= ~512 } if (flags & 65536 && !FS.isDir(node.mode)) { throw new FS.ErrnoError(54) } if (!created) { var errCode = FS.mayOpen(node, flags); if (errCode) { throw new FS.ErrnoError(errCode) } } if (flags & 512) { FS.truncate(node, 0) } flags &= ~(128 | 512 | 131072); var stream = FS.createStream({ node: node, path: FS.getPath(node), flags: flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end); if (stream.stream_ops.open) { stream.stream_ops.open(stream) } if (Module["logReadFiles"] && !(flags & 1)) { if (!FS.readFiles) FS.readFiles = {}; if (!(path in FS.readFiles)) { FS.readFiles[path] = 1; err("FS.trackingDelegate error on read file: " + path) } } try { if (FS.trackingDelegate["onOpenFile"]) { var trackingFlags = 0; if ((flags & 2097155) !== 1) { trackingFlags |= FS.tracking.openFlags.READ } if ((flags & 2097155) !== 0) { trackingFlags |= FS.tracking.openFlags.WRITE } FS.trackingDelegate["onOpenFile"](path, trackingFlags) } } catch (e) { err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message) } return stream }, close: function (stream) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if (stream.getdents) stream.getdents = null; try { if (stream.stream_ops.close) { stream.stream_ops.close(stream) } } catch (e) { throw e } finally { FS.closeStream(stream.fd) } stream.fd = null }, isClosed: function (stream) { return stream.fd === null }, llseek: function (stream, offset, whence) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if (!stream.seekable || !stream.stream_ops.llseek) { throw new FS.ErrnoError(70) } if (whence != 0 && whence != 1 && whence != 2) { throw new FS.ErrnoError(28) } stream.position = stream.stream_ops.llseek(stream, offset, whence); stream.ungotten = []; return stream.position }, read: function (stream, buffer, offset, length, position) { if (length < 0 || position < 0) { throw new FS.ErrnoError(28) } if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if ((stream.flags & 2097155) === 1) { throw new FS.ErrnoError(8) } if (FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(31) } if (!stream.stream_ops.read) { throw new FS.ErrnoError(28) } var seeking = typeof position !== "undefined"; if (!seeking) { position = stream.position } else if (!stream.seekable) { throw new FS.ErrnoError(70) } var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position); if (!seeking) stream.position += bytesRead; return bytesRead }, write: function (stream, buffer, offset, length, position, canOwn) { if (length < 0 || position < 0) { throw new FS.ErrnoError(28) } if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if ((stream.flags & 2097155) === 0) { throw new FS.ErrnoError(8) } if (FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(31) } if (!stream.stream_ops.write) { throw new FS.ErrnoError(28) } if (stream.seekable && stream.flags & 1024) { FS.llseek(stream, 0, 2) } var seeking = typeof position !== "undefined"; if (!seeking) { position = stream.position } else if (!stream.seekable) { throw new FS.ErrnoError(70) } var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn); if (!seeking) stream.position += bytesWritten; try { if (stream.path && FS.trackingDelegate["onWriteToFile"]) FS.trackingDelegate["onWriteToFile"](stream.path) } catch (e) { err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message) } return bytesWritten }, allocate: function (stream, offset, length) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if (offset < 0 || length <= 0) { throw new FS.ErrnoError(28) } if ((stream.flags & 2097155) === 0) { throw new FS.ErrnoError(8) } if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(43) } if (!stream.stream_ops.allocate) { throw new FS.ErrnoError(138) } stream.stream_ops.allocate(stream, offset, length) }, mmap: function (stream, buffer, offset, length, position, prot, flags) { if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) { throw new FS.ErrnoError(2) } if ((stream.flags & 2097155) === 1) { throw new FS.ErrnoError(2) } if (!stream.stream_ops.mmap) { throw new FS.ErrnoError(43) } return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags) }, msync: function (stream, buffer, offset, length, mmapFlags) { if (!stream || !stream.stream_ops.msync) { return 0 } return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags) }, munmap: function (stream) { return 0 }, ioctl: function (stream, cmd, arg) { if (!stream.stream_ops.ioctl) { throw new FS.ErrnoError(59) } return stream.stream_ops.ioctl(stream, cmd, arg) }, readFile: function (path, opts) { opts = opts || {}; opts.flags = opts.flags || "r"; opts.encoding = opts.encoding || "binary"; if (opts.encoding !== "utf8" && opts.encoding !== "binary") { throw new Error('Invalid encoding type "' + opts.encoding + '"') } var ret; var stream = FS.open(path, opts.flags); var stat = FS.stat(path); var length = stat.size; var buf = new Uint8Array(length); FS.read(stream, buf, 0, length, 0); if (opts.encoding === "utf8") { ret = UTF8ArrayToString(buf, 0) } else if (opts.encoding === "binary") { ret = buf } FS.close(stream); return ret }, writeFile: function (path, data, opts) { opts = opts || {}; opts.flags = opts.flags || "w"; var stream = FS.open(path, opts.flags, opts.mode); if (typeof data === "string") { var buf = new Uint8Array(lengthBytesUTF8(data) + 1); var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length); FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn) } else if (ArrayBuffer.isView(data)) { FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn) } else { throw new Error("Unsupported data type") } FS.close(stream) }, cwd: function () { return FS.currentPath }, chdir: function (path) { var lookup = FS.lookupPath(path, { follow: true }); if (lookup.node === null) { throw new FS.ErrnoError(44) } if (!FS.isDir(lookup.node.mode)) { throw new FS.ErrnoError(54) } var errCode = FS.nodePermissions(lookup.node, "x"); if (errCode) { throw new FS.ErrnoError(errCode) } FS.currentPath = lookup.path }, createDefaultDirectories: function () { FS.mkdir("/tmp"); FS.mkdir("/home"); FS.mkdir("/home/web_user") }, createDefaultDevices: function () { FS.mkdir("/dev"); FS.registerDevice(FS.makedev(1, 3), { read: function () { return 0 }, write: function (stream, buffer, offset, length, pos) { return length } }); FS.mkdev("/dev/null", FS.makedev(1, 3)); TTY.register(FS.makedev(5, 0), TTY.default_tty_ops); TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops); FS.mkdev("/dev/tty", FS.makedev(5, 0)); FS.mkdev("/dev/tty1", FS.makedev(6, 0)); var random_device; if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") { var randomBuffer = new Uint8Array(1); random_device = function () { crypto.getRandomValues(randomBuffer); return randomBuffer[0] } } else { } if (!random_device) { random_device = function () { abort("random_device") } } FS.createDevice("/dev", "random", random_device); FS.createDevice("/dev", "urandom", random_device); FS.mkdir("/dev/shm"); FS.mkdir("/dev/shm/tmp") }, createSpecialDirectories: function () { FS.mkdir("/proc"); FS.mkdir("/proc/self"); FS.mkdir("/proc/self/fd"); FS.mount({ mount: function () { var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73); node.node_ops = { lookup: function (parent, name) { var fd = +name; var stream = FS.getStream(fd); if (!stream) throw new FS.ErrnoError(8); var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function () { return stream.path } } }; ret.parent = ret; return ret } }; return node } }, {}, "/proc/self/fd") }, createStandardStreams: function () { if (Module["stdin"]) { FS.createDevice("/dev", "stdin", Module["stdin"]) } else { FS.symlink("/dev/tty", "/dev/stdin") } if (Module["stdout"]) { FS.createDevice("/dev", "stdout", null, Module["stdout"]) } else { FS.symlink("/dev/tty", "/dev/stdout") } if (Module["stderr"]) { FS.createDevice("/dev", "stderr", null, Module["stderr"]) } else { FS.symlink("/dev/tty1", "/dev/stderr") } var stdin = FS.open("/dev/stdin", "r"); var stdout = FS.open("/dev/stdout", "w"); var stderr = FS.open("/dev/stderr", "w") }, ensureErrnoError: function () { if (FS.ErrnoError) return; FS.ErrnoError = function ErrnoError(errno, node) { this.node = node; this.setErrno = function (errno) { this.errno = errno }; this.setErrno(errno); this.message = "FS error" }; FS.ErrnoError.prototype = new Error; FS.ErrnoError.prototype.constructor = FS.ErrnoError;[44].forEach(function (code) { FS.genericErrors[code] = new FS.ErrnoError(code); FS.genericErrors[code].stack = "<generic error, no stack>" }) }, staticInit: function () { FS.ensureErrnoError(); FS.nameTable = new Array(4096); FS.mount(MEMFS, {}, "/"); FS.createDefaultDirectories(); FS.createDefaultDevices(); FS.createSpecialDirectories(); FS.filesystems = { "MEMFS": MEMFS } }, init: function (input, output, error) { FS.init.initialized = true; FS.ensureErrnoError(); Module["stdin"] = input || Module["stdin"]; Module["stdout"] = output || Module["stdout"]; Module["stderr"] = error || Module["stderr"]; FS.createStandardStreams() }, quit: function () { FS.init.initialized = false; var fflush = Module["_fflush"]; if (fflush) fflush(0); for (var i = 0; i < FS.streams.length; i++) { var stream = FS.streams[i]; if (!stream) { continue } FS.close(stream) } }, getMode: function (canRead, canWrite) { var mode = 0; if (canRead) mode |= 292 | 73; if (canWrite) mode |= 146; return mode }, joinPath: function (parts, forceRelative) { var path = PATH.join.apply(null, parts); if (forceRelative && path[0] == "/") path = path.substr(1); return path }, absolutePath: function (relative, base) { return PATH_FS.resolve(base, relative) }, standardizePath: function (path) { return PATH.normalize(path) }, findObject: function (path, dontResolveLastLink) { var ret = FS.analyzePath(path, dontResolveLastLink); if (ret.exists) { return ret.object } else { setErrNo(ret.error); return null } }, analyzePath: function (path, dontResolveLastLink) { try { var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink }); path = lookup.path } catch (e) { } var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null }; try { var lookup = FS.lookupPath(path, { parent: true }); ret.parentExists = true; ret.parentPath = lookup.path; ret.parentObject = lookup.node; ret.name = PATH.basename(path); lookup = FS.lookupPath(path, { follow: !dontResolveLastLink }); ret.exists = true; ret.path = lookup.path; ret.object = lookup.node; ret.name = lookup.node.name; ret.isRoot = lookup.path === "/" } catch (e) { ret.error = e.errno } return ret }, createFolder: function (parent, name, canRead, canWrite) { var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name); var mode = FS.getMode(canRead, canWrite); return FS.mkdir(path, mode) }, createPath: function (parent, path, canRead, canWrite) { parent = typeof parent === "string" ? parent : FS.getPath(parent); var parts = path.split("/").reverse(); while (parts.length) { var part = parts.pop(); if (!part) continue; var current = PATH.join2(parent, part); try { FS.mkdir(current) } catch (e) { } parent = current } return current }, createFile: function (parent, name, properties, canRead, canWrite) { var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name); var mode = FS.getMode(canRead, canWrite); return FS.create(path, mode) }, createDataFile: function (parent, name, data, canRead, canWrite, canOwn) { var path = name ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name) : parent; var mode = FS.getMode(canRead, canWrite); var node = FS.create(path, mode); if (data) { if (typeof data === "string") { var arr = new Array(data.length); for (var i = 0, len = data.length; i < len; ++i)arr[i] = data.charCodeAt(i); data = arr } FS.chmod(node, mode | 146); var stream = FS.open(node, "w"); FS.write(stream, data, 0, data.length, 0, canOwn); FS.close(stream); FS.chmod(node, mode) } return node }, createDevice: function (parent, name, input, output) { var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name); var mode = FS.getMode(!!input, !!output); if (!FS.createDevice.major) FS.createDevice.major = 64; var dev = FS.makedev(FS.createDevice.major++, 0); FS.registerDevice(dev, { open: function (stream) { stream.seekable = false }, close: function (stream) { if (output && output.buffer && output.buffer.length) { output(10) } }, read: function (stream, buffer, offset, length, pos) { var bytesRead = 0; for (var i = 0; i < length; i++) { var result; try { result = input() } catch (e) { throw new FS.ErrnoError(29) } if (result === undefined && bytesRead === 0) { throw new FS.ErrnoError(6) } if (result === null || result === undefined) break; bytesRead++; buffer[offset + i] = result } if (bytesRead) { stream.node.timestamp = Date.now() } return bytesRead }, write: function (stream, buffer, offset, length, pos) { for (var i = 0; i < length; i++) { try { output(buffer[offset + i]) } catch (e) { throw new FS.ErrnoError(29) } } if (length) { stream.node.timestamp = Date.now() } return i } }); return FS.mkdev(path, mode, dev) }, createLink: function (parent, name, target, canRead, canWrite) { var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name); return FS.symlink(target, path) }, forceLoadFile: function (obj) { if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true; var success = true; if (typeof XMLHttpRequest !== "undefined") { throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.") } else if (read_) { try { obj.contents = intArrayFromString(read_(obj.url), true); obj.usedBytes = obj.contents.length } catch (e) { success = false } } else { throw new Error("Cannot load without read() or XMLHttpRequest.") } if (!success) setErrNo(29); return success }, createLazyFile: function (parent, name, url, canRead, canWrite) { function LazyUint8Array() { this.lengthKnown = false; this.chunks = [] } LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) { if (idx > this.length - 1 || idx < 0) { return undefined } var chunkOffset = idx % this.chunkSize; var chunkNum = idx / this.chunkSize | 0; return this.getter(chunkNum)[chunkOffset] }; LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) { this.getter = getter }; LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() { var xhr = new XMLHttpRequest; xhr.open("HEAD", url, false); xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status); var datalength = Number(xhr.getResponseHeader("Content-length")); var header; var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes"; var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip"; var chunkSize = 1024 * 1024; if (!hasByteServing) chunkSize = datalength; var doXHR = function (from, to) { if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!"); if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!"); var xhr = new XMLHttpRequest; xhr.open("GET", url, false); if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to); if (typeof Uint8Array != "undefined") xhr.responseType = "arraybuffer"; if (xhr.overrideMimeType) { xhr.overrideMimeType("text/plain; charset=x-user-defined") } xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status); if (xhr.response !== undefined) { return new Uint8Array(xhr.response || []) } else { return intArrayFromString(xhr.responseText || "", true) } }; var lazyArray = this; lazyArray.setDataGetter(function (chunkNum) { var start = chunkNum * chunkSize; var end = (chunkNum + 1) * chunkSize - 1; end = Math.min(end, datalength - 1); if (typeof lazyArray.chunks[chunkNum] === "undefined") { lazyArray.chunks[chunkNum] = doXHR(start, end) } if (typeof lazyArray.chunks[chunkNum] === "undefined") throw new Error("doXHR failed!"); return lazyArray.chunks[chunkNum] }); if (usesGzip || !datalength) { chunkSize = datalength = 1; datalength = this.getter(0).length; chunkSize = datalength; out("LazyFiles on gzip forces download of the whole file when length is accessed") } this._length = datalength; this._chunkSize = chunkSize; this.lengthKnown = true }; if (typeof XMLHttpRequest !== "undefined") { if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc"; var lazyArray = new LazyUint8Array; Object.defineProperties(lazyArray, { length: { get: function () { if (!this.lengthKnown) { this.cacheLength() } return this._length } }, chunkSize: { get: function () { if (!this.lengthKnown) { this.cacheLength() } return this._chunkSize } } }); var properties = { isDevice: false, contents: lazyArray } } else { var properties = { isDevice: false, url: url } } var node = FS.createFile(parent, name, properties, canRead, canWrite); if (properties.contents) { node.contents = properties.contents } else if (properties.url) { node.contents = null; node.url = properties.url } Object.defineProperties(node, { usedBytes: { get: function () { return this.contents.length } } }); var stream_ops = {}; var keys = Object.keys(node.stream_ops); keys.forEach(function (key) { var fn = node.stream_ops[key]; stream_ops[key] = function forceLoadLazyFile() { if (!FS.forceLoadFile(node)) { throw new FS.ErrnoError(29) } return fn.apply(null, arguments) } }); stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) { if (!FS.forceLoadFile(node)) { throw new FS.ErrnoError(29) } var contents = stream.node.contents; if (position >= contents.length) return 0; var size = Math.min(contents.length - position, length); if (contents.slice) { for (var i = 0; i < size; i++) { buffer[offset + i] = contents[position + i] } } else { for (var i = 0; i < size; i++) { buffer[offset + i] = contents.get(position + i) } } return size }; node.stream_ops = stream_ops; return node }, createPreloadedFile: function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) { Browser.init(); var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent; var dep = getUniqueRunDependency("cp " + fullname); function processData(byteArray) { function finish(byteArray) { if (preFinish) preFinish(); if (!dontCreateFile) { FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn) } if (onload) onload(); removeRunDependency(dep) } var handled = false; Module["preloadPlugins"].forEach(function (plugin) { if (handled) return; if (plugin["canHandle"](fullname)) { plugin["handle"](byteArray, fullname, finish, function () { if (onerror) onerror(); removeRunDependency(dep) }); handled = true } }); if (!handled) finish(byteArray) } addRunDependency(dep); if (typeof url == "string") { Browser.asyncLoad(url, function (byteArray) { processData(byteArray) }, onerror) } else { processData(url) } }, indexedDB: function () { return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB }, DB_NAME: function () { return "EM_FS_" + window.location.pathname }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function (paths, onload, onerror) { onload = onload || function () { }; onerror = onerror || function () { }; var indexedDB = FS.indexedDB(); try { var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION) } catch (e) { return onerror(e) } openRequest.onupgradeneeded = function openRequest_onupgradeneeded() { out("creating db"); var db = openRequest.result; db.createObjectStore(FS.DB_STORE_NAME) }; openRequest.onsuccess = function openRequest_onsuccess() { var db = openRequest.result; var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite"); var files = transaction.objectStore(FS.DB_STORE_NAME); var ok = 0, fail = 0, total = paths.length; function finish() { if (fail == 0) onload(); else onerror() } paths.forEach(function (path) { var putRequest = files.put(FS.analyzePath(path).object.contents, path); putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() }; putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() } }); transaction.onerror = onerror }; openRequest.onerror = onerror }, loadFilesFromDB: function (paths, onload, onerror) { onload = onload || function () { }; onerror = onerror || function () { }; var indexedDB = FS.indexedDB(); try { var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION) } catch (e) { return onerror(e) } openRequest.onupgradeneeded = onerror; openRequest.onsuccess = function openRequest_onsuccess() { var db = openRequest.result; try { var transaction = db.transaction([FS.DB_STORE_NAME], "readonly") } catch (e) { onerror(e); return } var files = transaction.objectStore(FS.DB_STORE_NAME); var ok = 0, fail = 0, total = paths.length; function finish() { if (fail == 0) onload(); else onerror() } paths.forEach(function (path) { var getRequest = files.get(path); getRequest.onsuccess = function getRequest_onsuccess() { if (FS.analyzePath(path).exists) { FS.unlink(path) } FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true); ok++; if (ok + fail == total) finish() }; getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() } }); transaction.onerror = onerror }; openRequest.onerror = onerror } }; var SYSCALLS = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function (dirfd, path) { if (path[0] !== "/") { var dir; if (dirfd === -100) { dir = FS.cwd() } else { var dirstream = FS.getStream(dirfd); if (!dirstream) throw new FS.ErrnoError(8); dir = dirstream.path } path = PATH.join2(dir, path) } return path }, doStat: function (func, path, buf) { try { var stat = func(path) } catch (e) { if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) { return -54 } throw e } HEAP32[buf >> 2] = stat.dev; HEAP32[buf + 4 >> 2] = 0; HEAP32[buf + 8 >> 2] = stat.ino; HEAP32[buf + 12 >> 2] = stat.mode; HEAP32[buf + 16 >> 2] = stat.nlink; HEAP32[buf + 20 >> 2] = stat.uid; HEAP32[buf + 24 >> 2] = stat.gid; HEAP32[buf + 28 >> 2] = stat.rdev; HEAP32[buf + 32 >> 2] = 0; tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1]; HEAP32[buf + 48 >> 2] = 4096; HEAP32[buf + 52 >> 2] = stat.blocks; HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0; HEAP32[buf + 60 >> 2] = 0; HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0; HEAP32[buf + 68 >> 2] = 0; HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0; HEAP32[buf + 76 >> 2] = 0; tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1]; return 0 }, doMsync: function (addr, stream, len, flags, offset) { var buffer = HEAPU8.slice(addr, addr + len); FS.msync(stream, buffer, offset, len, flags) }, doMkdir: function (path, mode) { path = PATH.normalize(path); if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1); FS.mkdir(path, mode, 0); return 0 }, doMknod: function (path, mode, dev) { switch (mode & 61440) { case 32768: case 8192: case 24576: case 4096: case 49152: break; default: return -28 }FS.mknod(path, mode, dev); return 0 }, doReadlink: function (path, buf, bufsize) { if (bufsize <= 0) return -28; var ret = FS.readlink(path); var len = Math.min(bufsize, lengthBytesUTF8(ret)); var endChar = HEAP8[buf + len]; stringToUTF8(ret, buf, bufsize + 1); HEAP8[buf + len] = endChar; return len }, doAccess: function (path, amode) { if (amode & ~7) { return -28 } var node; var lookup = FS.lookupPath(path, { follow: true }); node = lookup.node; if (!node) { return -44 } var perms = ""; if (amode & 4) perms += "r"; if (amode & 2) perms += "w"; if (amode & 1) perms += "x"; if (perms && FS.nodePermissions(node, perms)) { return -2 } return 0 }, doDup: function (path, flags, suggestFD) { var suggest = FS.getStream(suggestFD); if (suggest) FS.close(suggest); return FS.open(path, flags, 0, suggestFD, suggestFD).fd }, doReadv: function (stream, iov, iovcnt, offset) { var ret = 0; for (var i = 0; i < iovcnt; i++) { var ptr = HEAP32[iov + i * 8 >> 2]; var len = HEAP32[iov + (i * 8 + 4) >> 2]; var curr = FS.read(stream, HEAP8, ptr, len, offset); if (curr < 0) return -1; ret += curr; if (curr < len) break } return ret }, doWritev: function (stream, iov, iovcnt, offset) { var ret = 0; for (var i = 0; i < iovcnt; i++) { var ptr = HEAP32[iov + i * 8 >> 2]; var len = HEAP32[iov + (i * 8 + 4) >> 2]; var curr = FS.write(stream, HEAP8, ptr, len, offset); if (curr < 0) return -1; ret += curr } return ret }, varargs: undefined, get: function () { SYSCALLS.varargs += 4; var ret = HEAP32[SYSCALLS.varargs - 4 >> 2]; return ret }, getStr: function (ptr) { var ret = UTF8ToString(ptr); return ret }, getStreamFromFD: function (fd) { var stream = FS.getStream(fd); if (!stream) throw new FS.ErrnoError(8); return stream }, get64: function (low, high) { return low } }; function ___sys_fcntl64(fd, cmd, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(fd); switch (cmd) { case 0: { var arg = SYSCALLS.get(); if (arg < 0) { return -28 } var newStream; newStream = FS.open(stream.path, stream.flags, 0, arg); return newStream.fd } case 1: case 2: return 0; case 3: return stream.flags; case 4: { var arg = SYSCALLS.get(); stream.flags |= arg; return 0 } case 12: { var arg = SYSCALLS.get(); var offset = 0; HEAP16[arg + offset >> 1] = 2; return 0 } case 13: case 14: return 0; case 16: case 8: return -28; case 9: setErrNo(28); return -1; default: { return -28 } } } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return -e.errno } } function ___sys_fstat64(fd, buf) { try { var stream = SYSCALLS.getStreamFromFD(fd); return SYSCALLS.doStat(FS.stat, stream.path, buf) } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return -e.errno } } function ___sys_ioctl(fd, op, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(fd); switch (op) { case 21509: case 21505: { if (!stream.tty) return -59; return 0 } case 21510: case 21511: case 21512: case 21506: case 21507: case 21508: { if (!stream.tty) return -59; return 0 } case 21519: { if (!stream.tty) return -59; var argp = SYSCALLS.get(); HEAP32[argp >> 2] = 0; return 0 } case 21520: { if (!stream.tty) return -59; return -28 } case 21531: { var argp = SYSCALLS.get(); return FS.ioctl(stream, op, argp) } case 21523: { if (!stream.tty) return -59; return 0 } case 21524: { if (!stream.tty) return -59; return 0 } default: abort("bad ioctl syscall " + op) } } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return -e.errno } } function syscallMunmap(addr, len) { if ((addr | 0) === -1 || len === 0) { return -28 } var info = SYSCALLS.mappings[addr]; if (!info) return 0; if (len === info.len) { var stream = FS.getStream(info.fd); if (info.prot & 2) { SYSCALLS.doMsync(addr, stream, len, info.flags, info.offset) } FS.munmap(stream); SYSCALLS.mappings[addr] = null; if (info.allocated) { _free(info.malloc) } } return 0 } function ___sys_munmap(addr, len) { try { return syscallMunmap(addr, len) } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return -e.errno } } function ___sys_open(path, flags, varargs) { SYSCALLS.varargs = varargs; try { var pathname = SYSCALLS.getStr(path); var mode = SYSCALLS.get(); var stream = FS.open(pathname, flags, mode); return stream.fd } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return -e.errno } } function ___sys_read(fd, buf, count) { try { var stream = SYSCALLS.getStreamFromFD(fd); return FS.read(stream, HEAP8, buf, count) } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return -e.errno } } function ___sys_stat64(path, buf) { try { path = SYSCALLS.getStr(path); return SYSCALLS.doStat(FS.stat, path, buf) } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return -e.errno } } function _abort() { abort() } function _emscripten_memcpy_big(dest, src, num) { HEAPU8.copyWithin(dest, src, src + num) } function _emscripten_get_heap_size() { return HEAPU8.length } function emscripten_realloc_buffer(size) { try { wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16); updateGlobalBufferAndViews(wasmMemory.buffer); return 1 } catch (e) { } } function _emscripten_resize_heap(requestedSize) { var oldSize = _emscripten_get_heap_size(); var PAGE_MULTIPLE = 65536; var maxHeapSize = 2147483648; if (requestedSize > maxHeapSize) { return false } var minHeapSize = 16777216; for (var cutDown = 1; cutDown <= 4; cutDown *= 2) { var overGrownHeapSize = oldSize * (1 + .2 / cutDown); overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296); var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE)); var replacement = emscripten_realloc_buffer(newSize); if (replacement) { return true } } return false } var ENV = {}; function __getExecutableName() { return thisProgram || "./this.program" } function getEnvStrings() { if (!getEnvStrings.strings) { var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", "_": __getExecutableName() }; for (var x in ENV) { env[x] = ENV[x] } var strings = []; for (var x in env) { strings.push(x + "=" + env[x]) } getEnvStrings.strings = strings } return getEnvStrings.strings } function _environ_get(__environ, environ_buf) { var bufSize = 0; getEnvStrings().forEach(function (string, i) { var ptr = environ_buf + bufSize; HEAP32[__environ + i * 4 >> 2] = ptr; writeAsciiToMemory(string, ptr); bufSize += string.length + 1 }); return 0 } function _environ_sizes_get(penviron_count, penviron_buf_size) { var strings = getEnvStrings(); HEAP32[penviron_count >> 2] = strings.length; var bufSize = 0; strings.forEach(function (string) { bufSize += string.length + 1 }); HEAP32[penviron_buf_size >> 2] = bufSize; return 0 } function _exit(status) { exit(status) } function _fd_close(fd) { try { var stream = SYSCALLS.getStreamFromFD(fd); FS.close(stream); return 0 } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return e.errno } } function _fd_fdstat_get(fd, pbuf) { try { var stream = SYSCALLS.getStreamFromFD(fd); var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4; HEAP8[pbuf >> 0] = type; return 0 } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return e.errno } } function _fd_read(fd, iov, iovcnt, pnum) { try { var stream = SYSCALLS.getStreamFromFD(fd); var num = SYSCALLS.doReadv(stream, iov, iovcnt); HEAP32[pnum >> 2] = num; return 0 } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return e.errno } } function _fd_seek(fd, offset_low, offset_high, whence, newOffset) { try { var stream = SYSCALLS.getStreamFromFD(fd); var HIGH_OFFSET = 4294967296; var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0); var DOUBLE_LIMIT = 9007199254740992; if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) { return -61 } FS.llseek(stream, offset, whence); tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1]; if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; return 0 } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return e.errno } } function _fd_write(fd, iov, iovcnt, pnum) { try { var stream = SYSCALLS.getStreamFromFD(fd); var num = SYSCALLS.doWritev(stream, iov, iovcnt); HEAP32[pnum >> 2] = num; return 0 } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return e.errno } } function __isLeapYear(year) { return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) } function __arraySum(array, index) { var sum = 0; for (var i = 0; i <= index; sum += array[i++]) { } return sum } var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; function __addDays(date, days) { var newDate = new Date(date.getTime()); while (days > 0) { var leap = __isLeapYear(newDate.getFullYear()); var currentMonth = newDate.getMonth(); var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth]; if (days > daysInCurrentMonth - newDate.getDate()) { days -= daysInCurrentMonth - newDate.getDate() + 1; newDate.setDate(1); if (currentMonth < 11) { newDate.setMonth(currentMonth + 1) } else { newDate.setMonth(0); newDate.setFullYear(newDate.getFullYear() + 1) } } else { newDate.setDate(newDate.getDate() + days); return newDate } } return newDate } function _strftime(s, maxsize, format, tm) { var tm_zone = HEAP32[tm + 40 >> 2]; var date = { tm_sec: HEAP32[tm >> 2], tm_min: HEAP32[tm + 4 >> 2], tm_hour: HEAP32[tm + 8 >> 2], tm_mday: HEAP32[tm + 12 >> 2], tm_mon: HEAP32[tm + 16 >> 2], tm_year: HEAP32[tm + 20 >> 2], tm_wday: HEAP32[tm + 24 >> 2], tm_yday: HEAP32[tm + 28 >> 2], tm_isdst: HEAP32[tm + 32 >> 2], tm_gmtoff: HEAP32[tm + 36 >> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" }; var pattern = UTF8ToString(format); var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" }; for (var rule in EXPANSION_RULES_1) { pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]) } var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]; var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]; function leadingSomething(value, digits, character) { var str = typeof value === "number" ? value.toString() : value || ""; while (str.length < digits) { str = character[0] + str } return str } function leadingNulls(value, digits) { return leadingSomething(value, digits, "0") } function compareByDay(date1, date2) { function sgn(value) { return value < 0 ? -1 : value > 0 ? 1 : 0 } var compare; if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) { if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) { compare = sgn(date1.getDate() - date2.getDate()) } } return compare } function getFirstWeekStartDate(janFourth) { switch (janFourth.getDay()) { case 0: return new Date(janFourth.getFullYear() - 1, 11, 29); case 1: return janFourth; case 2: return new Date(janFourth.getFullYear(), 0, 3); case 3: return new Date(janFourth.getFullYear(), 0, 2); case 4: return new Date(janFourth.getFullYear(), 0, 1); case 5: return new Date(janFourth.getFullYear() - 1, 11, 31); case 6: return new Date(janFourth.getFullYear() - 1, 11, 30) } } function getWeekBasedYear(date) { var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday); var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4); var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4); var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear); var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear); if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) { if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) { return thisDate.getFullYear() + 1 } else { return thisDate.getFullYear() } } else { return thisDate.getFullYear() - 1 } } var EXPANSION_RULES_2 = { "%a": function (date) { return WEEKDAYS[date.tm_wday].substring(0, 3) }, "%A": function (date) { return WEEKDAYS[date.tm_wday] }, "%b": function (date) { return MONTHS[date.tm_mon].substring(0, 3) }, "%B": function (date) { return MONTHS[date.tm_mon] }, "%C": function (date) { var year = date.tm_year + 1900; return leadingNulls(year / 100 | 0, 2) }, "%d": function (date) { return leadingNulls(date.tm_mday, 2) }, "%e": function (date) { return leadingSomething(date.tm_mday, 2, " ") }, "%g": function (date) { return getWeekBasedYear(date).toString().substring(2) }, "%G": function (date) { return getWeekBasedYear(date) }, "%H": function (date) { return leadingNulls(date.tm_hour, 2) }, "%I": function (date) { var twelveHour = date.tm_hour; if (twelveHour == 0) twelveHour = 12; else if (twelveHour > 12) twelveHour -= 12; return leadingNulls(twelveHour, 2) }, "%j": function (date) { return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3) }, "%m": function (date) { return leadingNulls(date.tm_mon + 1, 2) }, "%M": function (date) { return leadingNulls(date.tm_min, 2) }, "%n": function () { return "\n" }, "%p": function (date) { if (date.tm_hour >= 0 && date.tm_hour < 12) { return "AM" } else { return "PM" } }, "%S": function (date) { return leadingNulls(date.tm_sec, 2) }, "%t": function () { return "\t" }, "%u": function (date) { return date.tm_wday || 7 }, "%U": function (date) { var janFirst = new Date(date.tm_year + 1900, 0, 1); var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay()); var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday); if (compareByDay(firstSunday, endDate) < 0) { var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31; var firstSundayUntilEndJanuary = 31 - firstSunday.getDate(); var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate(); return leadingNulls(Math.ceil(days / 7), 2) } return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00" }, "%V": function (date) { var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4); var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4); var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear); var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear); var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday); if (compareByDay(endDate, firstWeekStartThisYear) < 0) { return "53" } if (compareByDay(firstWeekStartNextYear, endDate) <= 0) { return "01" } var daysDifference; if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) { daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate() } else { daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate() } return leadingNulls(Math.ceil(daysDifference / 7), 2) }, "%w": function (date) { return date.tm_wday }, "%W": function (date) { var janFirst = new Date(date.tm_year, 0, 1); var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1); var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday); if (compareByDay(firstMonday, endDate) < 0) { var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31; var firstMondayUntilEndJanuary = 31 - firstMonday.getDate(); var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate(); return leadingNulls(Math.ceil(days / 7), 2) } return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00" }, "%y": function (date) { return (date.tm_year + 1900).toString().substring(2) }, "%Y": function (date) { return date.tm_year + 1900 }, "%z": function (date) { var off = date.tm_gmtoff; var ahead = off >= 0; off = Math.abs(off) / 60; off = off / 60 * 100 + off % 60; return (ahead ? "+" : "-") + String("0000" + off).slice(-4) }, "%Z": function (date) { return date.tm_zone }, "%%": function () { return "%" } }; for (var rule in EXPANSION_RULES_2) { if (pattern.indexOf(rule) >= 0) { pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date)) } } var bytes = intArrayFromString(pattern, false); if (bytes.length > maxsize) { return 0 } writeArrayToMemory(bytes, s); return bytes.length - 1 } function _strftime_l(s, maxsize, format, tm) { return _strftime(s, maxsize, format, tm) } var FSNode = function (parent, name, mode, rdev) { if (!parent) { parent = this } this.parent = parent; this.mount = parent.mount; this.mounted = null; this.id = FS.nextInode++; this.name = name; this.mode = mode; this.node_ops = {}; this.stream_ops = {}; this.rdev = rdev }; var readMode = 292 | 73; var writeMode = 146; Object.defineProperties(FSNode.prototype, { read: { get: function () { return (this.mode & readMode) === readMode }, set: function (val) { val ? this.mode |= readMode : this.mode &= ~readMode } }, write: { get: function () { return (this.mode & writeMode) === writeMode }, set: function (val) { val ? this.mode |= writeMode : this.mode &= ~writeMode } }, isFolder: { get: function () { return FS.isDir(this.mode) } }, isDevice: { get: function () { return FS.isChrdev(this.mode) } } }); FS.FSNode = FSNode; FS.staticInit(); Module["FS_createFolder"] = FS.createFolder; Module["FS_createPath"] = FS.createPath; Module["FS_createDataFile"] = FS.createDataFile; Module["FS_createPreloadedFile"] = FS.createPreloadedFile; Module["FS_createLazyFile"] = FS.createLazyFile; Module["FS_createLink"] = FS.createLink; Module["FS_createDevice"] = FS.createDevice; Module["FS_unlink"] = FS.unlink; function intArrayFromString(stringy, dontAddNull, length) { var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1; var u8array = new Array(len); var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length); if (dontAddNull) u8array.length = numBytesWritten; return u8array } var asmLibraryArg = { "h": ___cxa_allocate_exception, "g": ___cxa_throw, "q": ___map_file, "c": ___sys_fcntl64, "k": ___sys_fstat64, "i": ___sys_ioctl, "p": ___sys_munmap, "d": ___sys_open, "u": ___sys_read, "j": ___sys_stat64, "f": _abort, "m": _emscripten_memcpy_big, "n": _emscripten_resize_heap, "s": _environ_get, "t": _environ_sizes_get, "e": _exit, "b": _fd_close, "r": _fd_fdstat_get, "v": _fd_read, "l": _fd_seek, "a": _fd_write, "memory": wasmMemory, "o": _strftime_l, "table": wasmTable }; var asm = createWasm(); Module["asm"] = asm; var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function () { return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["w"]).apply(null, arguments) }; var _mecab_do2 = Module["_mecab_do2"] = function () { return (_mecab_do2 = Module["_mecab_do2"] = Module["asm"]["x"]).apply(null, arguments) }; var _free = Module["_free"] = function () { return (_free = Module["_free"] = Module["asm"]["y"]).apply(null, arguments) }; var ___errno_location = Module["___errno_location"] = function () { return (___errno_location = Module["___errno_location"] = Module["asm"]["z"]).apply(null, arguments) }; var _malloc = Module["_malloc"] = function () { return (_malloc = Module["_malloc"] = Module["asm"]["A"]).apply(null, arguments) }; var stackSave = Module["stackSave"] = function () { return (stackSave = Module["stackSave"] = Module["asm"]["B"]).apply(null, arguments) }; var stackAlloc = Module["stackAlloc"] = function () { return (stackAlloc = Module["stackAlloc"] = Module["asm"]["C"]).apply(null, arguments) }; var stackRestore = Module["stackRestore"] = function () { return (stackRestore = Module["stackRestore"] = Module["asm"]["D"]).apply(null, arguments) }; var dynCall_vi = Module["dynCall_vi"] = function () { return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["E"]).apply(null, arguments) }; var dynCall_v = Module["dynCall_v"] = function () { return (dynCall_v = Module["dynCall_v"] = Module["asm"]["F"]).apply(null, arguments) }; if (ENVIRONMENT_IS_WORKER) { function WebGLBuffer(id) { this.what = "buffer"; this.id = id } function WebGLProgram(id) { this.what = "program"; this.id = id; this.shaders = []; this.attributes = {}; this.attributeVec = []; this.nextAttributes = {}; this.nextAttributeVec = [] } function WebGLFramebuffer(id) { this.what = "frameBuffer"; this.id = id } function WebGLRenderbuffer(id) { this.what = "renderBuffer"; this.id = id } function WebGLTexture(id) { this.what = "texture"; this.id = id; this.binding = 0 } function WebGLWorker() { this.DEPTH_BUFFER_BIT = 256; this.STENCIL_BUFFER_BIT = 1024; this.COLOR_BUFFER_BIT = 16384; this.POINTS = 0; this.LINES = 1; this.LINE_LOOP = 2; this.LINE_STRIP = 3; this.TRIANGLES = 4; this.TRIANGLE_STRIP = 5; this.TRIANGLE_FAN = 6; this.ZERO = 0; this.ONE = 1; this.SRC_COLOR = 768; this.ONE_MINUS_SRC_COLOR = 769; this.SRC_ALPHA = 770; this.ONE_MINUS_SRC_ALPHA = 771; this.DST_ALPHA = 772; this.ONE_MINUS_DST_ALPHA = 773; this.DST_COLOR = 774; this.ONE_MINUS_DST_COLOR = 775; this.SRC_ALPHA_SATURATE = 776; this.FUNC_ADD = 32774; this.BLEND_EQUATION = 32777; this.BLEND_EQUATION_RGB = 32777; this.BLEND_EQUATION_ALPHA = 34877; this.FUNC_SUBTRACT = 32778; this.FUNC_REVERSE_SUBTRACT = 32779; this.BLEND_DST_RGB = 32968; this.BLEND_SRC_RGB = 32969; this.BLEND_DST_ALPHA = 32970; this.BLEND_SRC_ALPHA = 32971; this.CONSTANT_COLOR = 32769; this.ONE_MINUS_CONSTANT_COLOR = 32770; this.CONSTANT_ALPHA = 32771; this.ONE_MINUS_CONSTANT_ALPHA = 32772; this.BLEND_COLOR = 32773; this.ARRAY_BUFFER = 34962; this.ELEMENT_ARRAY_BUFFER = 34963; this.ARRAY_BUFFER_BINDING = 34964; this.ELEMENT_ARRAY_BUFFER_BINDING = 34965; this.STREAM_DRAW = 35040; this.STATIC_DRAW = 35044; this.DYNAMIC_DRAW = 35048; this.BUFFER_SIZE = 34660; this.BUFFER_USAGE = 34661; this.CURRENT_VERTEX_ATTRIB = 34342; this.FRONT = 1028; this.BACK = 1029; this.FRONT_AND_BACK = 1032; this.CULL_FACE = 2884; this.BLEND = 3042; this.DITHER = 3024; this.STENCIL_TEST = 2960; this.DEPTH_TEST = 2929; this.SCISSOR_TEST = 3089; this.POLYGON_OFFSET_FILL = 32823; this.SAMPLE_ALPHA_TO_COVERAGE = 32926; this.SAMPLE_COVERAGE = 32928; this.NO_ERROR = 0; this.INVALID_ENUM = 1280; this.INVALID_VALUE = 1281; this.INVALID_OPERATION = 1282; this.OUT_OF_MEMORY = 1285; this.CW = 2304; this.CCW = 2305; this.LINE_WIDTH = 2849; this.ALIASED_POINT_SIZE_RANGE = 33901; this.ALIASED_LINE_WIDTH_RANGE = 33902; this.CULL_FACE_MODE = 2885; this.FRONT_FACE = 2886; this.DEPTH_RANGE = 2928; this.DEPTH_WRITEMASK = 2930; this.DEPTH_CLEAR_VALUE = 2931; this.DEPTH_FUNC = 2932; this.STENCIL_CLEAR_VALUE = 2961; this.STENCIL_FUNC = 2962; this.STENCIL_FAIL = 2964; this.STENCIL_PASS_DEPTH_FAIL = 2965; this.STENCIL_PASS_DEPTH_PASS = 2966; this.STENCIL_REF = 2967; this.STENCIL_VALUE_MASK = 2963; this.STENCIL_WRITEMASK = 2968; this.STENCIL_BACK_FUNC = 34816; this.STENCIL_BACK_FAIL = 34817; this.STENCIL_BACK_PASS_DEPTH_FAIL = 34818; this.STENCIL_BACK_PASS_DEPTH_PASS = 34819; this.STENCIL_BACK_REF = 36003; this.STENCIL_BACK_VALUE_MASK = 36004; this.STENCIL_BACK_WRITEMASK = 36005; this.VIEWPORT = 2978; this.SCISSOR_BOX = 3088; this.COLOR_CLEAR_VALUE = 3106; this.COLOR_WRITEMASK = 3107; this.UNPACK_ALIGNMENT = 3317; this.PACK_ALIGNMENT = 3333; this.MAX_TEXTURE_SIZE = 3379; this.MAX_VIEWPORT_DIMS = 3386; this.SUBPIXEL_BITS = 3408; this.RED_BITS = 3410; this.GREEN_BITS = 3411; this.BLUE_BITS = 3412; this.ALPHA_BITS = 3413; this.DEPTH_BITS = 3414; this.STENCIL_BITS = 3415; this.POLYGON_OFFSET_UNITS = 10752; this.POLYGON_OFFSET_FACTOR = 32824; this.TEXTURE_BINDING_2D = 32873; this.SAMPLE_BUFFERS = 32936; this.SAMPLES = 32937; this.SAMPLE_COVERAGE_VALUE = 32938; this.SAMPLE_COVERAGE_INVERT = 32939; this.COMPRESSED_TEXTURE_FORMATS = 34467; this.DONT_CARE = 4352; this.FASTEST = 4353; this.NICEST = 4354; this.GENERATE_MIPMAP_HINT = 33170; this.BYTE = 5120; this.UNSIGNED_BYTE = 5121; this.SHORT = 5122; this.UNSIGNED_SHORT = 5123; this.INT = 5124; this.UNSIGNED_INT = 5125; this.FLOAT = 5126; this.DEPTH_COMPONENT = 6402; this.ALPHA = 6406; this.RGB = 6407; this.RGBA = 6408; this.LUMINANCE = 6409; this.LUMINANCE_ALPHA = 6410; this.UNSIGNED_SHORT_4_4_4_4 = 32819; this.UNSIGNED_SHORT_5_5_5_1 = 32820; this.UNSIGNED_SHORT_5_6_5 = 33635; this.FRAGMENT_SHADER = 35632; this.VERTEX_SHADER = 35633; this.MAX_VERTEX_ATTRIBS = 34921; this.MAX_VERTEX_UNIFORM_VECTORS = 36347; this.MAX_VARYING_VECTORS = 36348; this.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661; this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660; this.MAX_TEXTURE_IMAGE_UNITS = 34930; this.MAX_FRAGMENT_UNIFORM_VECTORS = 36349; this.SHADER_TYPE = 35663; this.DELETE_STATUS = 35712; this.LINK_STATUS = 35714; this.VALIDATE_STATUS = 35715; this.ATTACHED_SHADERS = 35717; this.ACTIVE_UNIFORMS = 35718; this.ACTIVE_ATTRIBUTES = 35721; this.SHADING_LANGUAGE_VERSION = 35724; this.CURRENT_PROGRAM = 35725; this.NEVER = 512; this.LESS = 513; this.EQUAL = 514; this.LEQUAL = 515; this.GREATER = 516; this.NOTEQUAL = 517; this.GEQUAL = 518; this.ALWAYS = 519; this.KEEP = 7680; this.REPLACE = 7681; this.INCR = 7682; this.DECR = 7683; this.INVERT = 5386; this.INCR_WRAP = 34055; this.DECR_WRAP = 34056; this.VENDOR = 7936; this.RENDERER = 7937; this.VERSION = 7938; this.NEAREST = 9728; this.LINEAR = 9729; this.NEAREST_MIPMAP_NEAREST = 9984; this.LINEAR_MIPMAP_NEAREST = 9985; this.NEAREST_MIPMAP_LINEAR = 9986; this.LINEAR_MIPMAP_LINEAR = 9987; this.TEXTURE_MAG_FILTER = 10240; this.TEXTURE_MIN_FILTER = 10241; this.TEXTURE_WRAP_S = 10242; this.TEXTURE_WRAP_T = 10243; this.TEXTURE_2D = 3553; this.TEXTURE = 5890; this.TEXTURE_CUBE_MAP = 34067; this.TEXTURE_BINDING_CUBE_MAP = 34068; this.TEXTURE_CUBE_MAP_POSITIVE_X = 34069; this.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070; this.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071; this.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072; this.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073; this.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074; this.MAX_CUBE_MAP_TEXTURE_SIZE = 34076; this.TEXTURE0 = 33984; this.TEXTURE1 = 33985; this.TEXTURE2 = 33986; this.TEXTURE3 = 33987; this.TEXTURE4 = 33988; this.TEXTURE5 = 33989; this.TEXTURE6 = 33990; this.TEXTURE7 = 33991; this.TEXTURE8 = 33992; this.TEXTURE9 = 33993; this.TEXTURE10 = 33994; this.TEXTURE11 = 33995; this.TEXTURE12 = 33996; this.TEXTURE13 = 33997; this.TEXTURE14 = 33998; this.TEXTURE15 = 33999; this.TEXTURE16 = 34e3; this.TEXTURE17 = 34001; this.TEXTURE18 = 34002; this.TEXTURE19 = 34003; this.TEXTURE20 = 34004; this.TEXTURE21 = 34005; this.TEXTURE22 = 34006; this.TEXTURE23 = 34007; this.TEXTURE24 = 34008; this.TEXTURE25 = 34009; this.TEXTURE26 = 34010; this.TEXTURE27 = 34011; this.TEXTURE28 = 34012; this.TEXTURE29 = 34013; this.TEXTURE30 = 34014; this.TEXTURE31 = 34015; this.ACTIVE_TEXTURE = 34016; this.REPEAT = 10497; this.CLAMP_TO_EDGE = 33071; this.MIRRORED_REPEAT = 33648; this.FLOAT_VEC2 = 35664; this.FLOAT_VEC3 = 35665; this.FLOAT_VEC4 = 35666; this.INT_VEC2 = 35667; this.INT_VEC3 = 35668; this.INT_VEC4 = 35669; this.BOOL = 35670; this.BOOL_VEC2 = 35671; this.BOOL_VEC3 = 35672; this.BOOL_VEC4 = 35673; this.FLOAT_MAT2 = 35674; this.FLOAT_MAT3 = 35675; this.FLOAT_MAT4 = 35676; this.SAMPLER_2D = 35678; this.SAMPLER_3D = 35679; this.SAMPLER_CUBE = 35680; this.VERTEX_ATTRIB_ARRAY_ENABLED = 34338; this.VERTEX_ATTRIB_ARRAY_SIZE = 34339; this.VERTEX_ATTRIB_ARRAY_STRIDE = 34340; this.VERTEX_ATTRIB_ARRAY_TYPE = 34341; this.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922; this.VERTEX_ATTRIB_ARRAY_POINTER = 34373; this.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975; this.IMPLEMENTATION_COLOR_READ_TYPE = 35738; this.IMPLEMENTATION_COLOR_READ_FORMAT = 35739; this.COMPILE_STATUS = 35713; this.LOW_FLOAT = 36336; this.MEDIUM_FLOAT = 36337; this.HIGH_FLOAT = 36338; this.LOW_INT = 36339; this.MEDIUM_INT = 36340; this.HIGH_INT = 36341; this.FRAMEBUFFER = 36160; this.RENDERBUFFER = 36161; this.RGBA4 = 32854; this.RGB5_A1 = 32855; this.RGB565 = 36194; this.DEPTH_COMPONENT16 = 33189; this.STENCIL_INDEX = 6401; this.STENCIL_INDEX8 = 36168; this.DEPTH_STENCIL = 34041; this.RENDERBUFFER_WIDTH = 36162; this.RENDERBUFFER_HEIGHT = 36163; this.RENDERBUFFER_INTERNAL_FORMAT = 36164; this.RENDERBUFFER_RED_SIZE = 36176; this.RENDERBUFFER_GREEN_SIZE = 36177; this.RENDERBUFFER_BLUE_SIZE = 36178; this.RENDERBUFFER_ALPHA_SIZE = 36179; this.RENDERBUFFER_DEPTH_SIZE = 36180; this.RENDERBUFFER_STENCIL_SIZE = 36181; this.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048; this.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049; this.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050; this.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051; this.COLOR_ATTACHMENT0 = 36064; this.DEPTH_ATTACHMENT = 36096; this.STENCIL_ATTACHMENT = 36128; this.DEPTH_STENCIL_ATTACHMENT = 33306; this.NONE = 0; this.FRAMEBUFFER_COMPLETE = 36053; this.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054; this.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055; this.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057; this.FRAMEBUFFER_UNSUPPORTED = 36061; this.ACTIVE_TEXTURE = 34016; this.FRAMEBUFFER_BINDING = 36006; this.RENDERBUFFER_BINDING = 36007; this.MAX_RENDERBUFFER_SIZE = 34024; this.INVALID_FRAMEBUFFER_OPERATION = 1286; this.UNPACK_FLIP_Y_WEBGL = 37440; this.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441; this.CONTEXT_LOST_WEBGL = 37442; this.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443; this.BROWSER_DEFAULT_WEBGL = 37444; var commandBuffer = []; var nextId = 1; var bindings = { texture2D: null, arrayBuffer: null, elementArrayBuffer: null, program: null, framebuffer: null, activeTexture: this.TEXTURE0, generateMipmapHint: this.DONT_CARE, blendSrcRGB: this.ONE, blendSrcAlpha: this.ONE, blendDstRGB: this.ZERO, blendDstAlpha: this.ZERO, blendEquationRGB: this.FUNC_ADD, blendEquationAlpha: this.FUNC_ADD, enabledState: {} }; var stateDisabledByDefault = [this.BLEND, this.CULL_FACE, this.DEPTH_TEST, this.DITHER, this.POLYGON_OFFSET_FILL, this.SAMPLE_ALPHA_TO_COVERAGE, this.SAMPLE_COVERAGE, this.SCISSOR_TEST, this.STENCIL_TEST]; for (var i in stateDisabledByDefault) { bindings.enabledState[stateDisabledByDefault[i]] = false } var that = this; this.onmessage = function (msg) { switch (msg.op) { case "setPrefetched": { WebGLWorker.prototype.prefetchedParameters = msg.parameters; WebGLWorker.prototype.prefetchedExtensions = msg.extensions; WebGLWorker.prototype.prefetchedPrecisions = msg.precisions; removeRunDependency("gl-prefetch"); break } default: throw "weird gl onmessage " + JSON.stringify(msg) } }; function revname(name) { for (var x in that) if (that[x] === name) return x; return null } this.getParameter = function (name) { assert(name); if (name in this.prefetchedParameters) return this.prefetchedParameters[name]; switch (name) { case this.TEXTURE_BINDING_2D: { return bindings.texture2D } case this.ARRAY_BUFFER_BINDING: { return bindings.arrayBuffer } case this.ELEMENT_ARRAY_BUFFER_BINDING: { return bindings.elementArrayBuffer } case this.CURRENT_PROGRAM: { return bindings.program } case this.FRAMEBUFFER_BINDING: { return bindings.framebuffer } case this.ACTIVE_TEXTURE: { return bindings.activeTexture } case this.GENERATE_MIPMAP_HINT: { return bindings.generateMipmapHint } case this.BLEND_SRC_RGB: { return bindings.blendSrcRGB } case this.BLEND_SRC_ALPHA: { return bindings.blendSrcAlpha } case this.BLEND_DST_RGB: { return bindings.blendDstRGB } case this.BLEND_DST_ALPHA: { return bindings.blendDstAlpha } case this.BLEND_EQUATION_RGB: { return bindings.blendEquationRGB } case this.BLEND_EQUATION_ALPHA: { return bindings.blendEquationAlpha } default: { if (bindings.enabledState[name] !== undefined) return bindings.enabledState[name]; throw "TODO: get parameter " + name + " : " + revname(name) } } }; this.getExtension = function (name) { var i = this.prefetchedExtensions.indexOf(name); if (i < 0) return null; commandBuffer.push(1, name); switch (name) { case "EXT_texture_filter_anisotropic": { return { TEXTURE_MAX_ANISOTROPY_EXT: 34046, MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047 } } case "WEBGL_draw_buffers": { return { COLOR_ATTACHMENT0_WEBGL: 36064, COLOR_ATTACHMENT1_WEBGL: 36065, COLOR_ATTACHMENT2_WEBGL: 36066, COLOR_ATTACHMENT3_WEBGL: 36067, COLOR_ATTACHMENT4_WEBGL: 36068, COLOR_ATTACHMENT5_WEBGL: 36069, COLOR_ATTACHMENT6_WEBGL: 36070, COLOR_ATTACHMENT7_WEBGL: 36071, COLOR_ATTACHMENT8_WEBGL: 36072, COLOR_ATTACHMENT9_WEBGL: 36073, COLOR_ATTACHMENT10_WEBGL: 36074, COLOR_ATTACHMENT11_WEBGL: 36075, COLOR_ATTACHMENT12_WEBGL: 36076, COLOR_ATTACHMENT13_WEBGL: 36077, COLOR_ATTACHMENT14_WEBGL: 36078, COLOR_ATTACHMENT15_WEBGL: 36079, DRAW_BUFFER0_WEBGL: 34853, DRAW_BUFFER1_WEBGL: 34854, DRAW_BUFFER2_WEBGL: 34855, DRAW_BUFFER3_WEBGL: 34856, DRAW_BUFFER4_WEBGL: 34857, DRAW_BUFFER5_WEBGL: 34858, DRAW_BUFFER6_WEBGL: 34859, DRAW_BUFFER7_WEBGL: 34860, DRAW_BUFFER8_WEBGL: 34861, DRAW_BUFFER9_WEBGL: 34862, DRAW_BUFFER10_WEBGL: 34863, DRAW_BUFFER11_WEBGL: 34864, DRAW_BUFFER12_WEBGL: 34865, DRAW_BUFFER13_WEBGL: 34866, DRAW_BUFFER14_WEBGL: 34867, DRAW_BUFFER15_WEBGL: 34868, MAX_COLOR_ATTACHMENTS_WEBGL: 36063, MAX_DRAW_BUFFERS_WEBGL: 34852, drawBuffersWEBGL: function (buffers) { that.drawBuffersWEBGL(buffers) } } } case "OES_standard_derivatives": { return { FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723 } } }return true }; this.getSupportedExtensions = function () { return this.prefetchedExtensions }; this.getShaderPrecisionFormat = function (shaderType, precisionType) { return this.prefetchedPrecisions[shaderType][precisionType] }; this.enable = function (cap) { commandBuffer.push(2, cap); bindings.enabledState[cap] = true }; this.isEnabled = function (cap) { return bindings.enabledState[cap] }; this.disable = function (cap) { commandBuffer.push(3, cap); bindings.enabledState[cap] = false }; this.clear = function (mask) { commandBuffer.push(4, mask) }; this.clearColor = function (r, g, b, a) { commandBuffer.push(5, r, g, b, a) }; this.createShader = function (type) { var id = nextId++; commandBuffer.push(6, type, id); return { id: id, what: "shader", type: type } }; this.deleteShader = function (shader) { if (!shader) return; commandBuffer.push(7, shader.id) }; this.shaderSource = function (shader, source) { shader.source = source; commandBuffer.push(8, shader.id, source) }; this.compileShader = function (shader) { commandBuffer.push(9, shader.id) }; this.getShaderInfoLog = function (shader) { return "" }; this.createProgram = function () { var id = nextId++; commandBuffer.push(10, id); return new WebGLProgram(id) }; this.deleteProgram = function (program) { if (!program) return; commandBuffer.push(11, program.id) }; this.attachShader = function (program, shader) { program.shaders.push(shader); commandBuffer.push(12, program.id, shader.id) }; this.bindAttribLocation = function (program, index, name) { program.nextAttributes[name] = { what: "attribute", name: name, size: -1, location: index, type: "?" }; program.nextAttributeVec[index] = name; commandBuffer.push(13, program.id, index, name) }; this.getAttribLocation = function (program, name) { if (name in program.attributes) return program.attributes[name].location; return -1 }; this.linkProgram = function (program) { function getTypeId(text) { switch (text) { case "bool": return that.BOOL; case "int": return that.INT; case "uint": return that.UNSIGNED_INT; case "float": return that.FLOAT; case "vec2": return that.FLOAT_VEC2; case "vec3": return that.FLOAT_VEC3; case "vec4": return that.FLOAT_VEC4; case "ivec2": return that.INT_VEC2; case "ivec3": return that.INT_VEC3; case "ivec4": return that.INT_VEC4; case "bvec2": return that.BOOL_VEC2; case "bvec3": return that.BOOL_VEC3; case "bvec4": return that.BOOL_VEC4; case "mat2": return that.FLOAT_MAT2; case "mat3": return that.FLOAT_MAT3; case "mat4": return that.FLOAT_MAT4; case "sampler2D": return that.SAMPLER_2D; case "sampler3D": return that.SAMPLER_3D; case "samplerCube": return that.SAMPLER_CUBE; default: throw "not yet recognized type text: " + text } } function parseElementType(shader, type, obj, vec) { var source = shader.source; source = source.replace(/\n/g, "|\n"); var newItems = source.match(new RegExp(type + "\\s+\\w+\\s+[\\w,\\s[\\]]+;", "g")); if (!newItems) return; newItems.forEach(function (item) { var m = new RegExp(type + "\\s+(\\w+)\\s+([\\w,\\s[\\]]+);").exec(item); assert(m); m[2].split(",").map(function (name) { name = name.trim(); return name.search(/\s/) >= 0 ? "" : name }).filter(function (name) { return !!name }).forEach(function (name) { var size = 1; var open = name.indexOf("["); var fullname = name; if (open >= 0) { var close = name.indexOf("]"); size = parseInt(name.substring(open + 1, close)); name = name.substr(0, open); fullname = name + "[0]" } if (!obj[name]) { obj[name] = { what: type, name: fullname, size: size, location: -1, type: getTypeId(m[1]) }; if (vec) vec.push(name) } }) }) } program.uniforms = {}; program.uniformVec = []; program.attributes = program.nextAttributes; program.attributeVec = program.nextAttributeVec; program.nextAttributes = {}; program.nextAttributeVec = []; var existingAttributes = {}; program.shaders.forEach(function (shader) { parseElementType(shader, "uniform", program.uniforms, program.uniformVec); parseElementType(shader, "attribute", existingAttributes, null) }); for (var attr in existingAttributes) { if (!(attr in program.attributes)) { var index = program.attributeVec.length; program.attributes[attr] = { what: "attribute", name: attr, size: -1, location: index, type: "?" }; program.attributeVec[index] = attr; commandBuffer.push(13, program.id, index, attr) } program.attributes[attr].size = existingAttributes[attr].size; program.attributes[attr].type = existingAttributes[attr].type } commandBuffer.push(14, program.id) }; this.getProgramParameter = function (program, name) { switch (name) { case this.ACTIVE_UNIFORMS: return program.uniformVec.length; case this.ACTIVE_ATTRIBUTES: return program.attributeVec.length; case this.LINK_STATUS: { commandBuffer.push(15, program.id, name); return true } default: throw "bad getProgramParameter " + revname(name) } }; this.getActiveAttrib = function (program, index) { var name = program.attributeVec[index]; if (!name) return null; return program.attributes[name] }; this.getActiveUniform = function (program, index) { var name = program.uniformVec[index]; if (!name) return null; return program.uniforms[name] }; this.getUniformLocation = function (program, name) { var fullname = name; var index = -1; var open = name.indexOf("["); if (open >= 0) { var close = name.indexOf("]"); index = parseInt(name.substring(open + 1, close)); name = name.substr(0, open) } if (!(name in program.uniforms)) return null; var id = nextId++; commandBuffer.push(16, program.id, fullname, id); return { what: "location", uniform: program.uniforms[name], id: id, index: index } }; this.getProgramInfoLog = function (shader) { return "" }; this.useProgram = function (program) { commandBuffer.push(17, program ? program.id : 0); bindings.program = program }; this.uniform1i = function (location, data) { if (!location) return; commandBuffer.push(18, location.id, data) }; this.uniform1f = function (location, data) { if (!location) return; commandBuffer.push(19, location.id, data) }; this.uniform3fv = function (location, data) { if (!location) return; commandBuffer.push(20, location.id, new Float32Array(data)) }; this.uniform4f = function (location, x, y, z, w) { if (!location) return; commandBuffer.push(21, location.id, new Float32Array([x, y, z, w])) }; this.uniform4fv = function (location, data) { if (!location) return; commandBuffer.push(21, location.id, new Float32Array(data)) }; this.uniformMatrix4fv = function (location, transpose, data) { if (!location) return; commandBuffer.push(22, location.id, transpose, new Float32Array(data)) }; this.vertexAttrib4fv = function (index, values) { commandBuffer.push(23, index, new Float32Array(values)) }; this.createBuffer = function () { var id = nextId++; commandBuffer.push(24, id); return new WebGLBuffer(id) }; this.deleteBuffer = function (buffer) { if (!buffer) return; commandBuffer.push(25, buffer.id) }; this.bindBuffer = function (target, buffer) { commandBuffer.push(26, target, buffer ? buffer.id : 0); switch (target) { case this.ARRAY_BUFFER_BINDING: { bindings.arrayBuffer = buffer; break } case this.ELEMENT_ARRAY_BUFFER_BINDING: { bindings.elementArrayBuffer = buffer; break } } }; function duplicate(something) { if (!something || typeof something === "number") return something; if (something.slice) return something.slice(0); return new something.constructor(something) } this.bufferData = function (target, something, usage) { commandBuffer.push(27, target, duplicate(something), usage) }; this.bufferSubData = function (target, offset, something) { commandBuffer.push(28, target, offset, duplicate(something)) }; this.viewport = function (x, y, w, h) { commandBuffer.push(29, x, y, w, h) }; this.vertexAttribPointer = function (index, size, type, normalized, stride, offset) { commandBuffer.push(30, index, size, type, normalized, stride, offset) }; this.enableVertexAttribArray = function (index) { commandBuffer.push(31, index) }; this.disableVertexAttribArray = function (index) { commandBuffer.push(32, index) }; this.drawArrays = function (mode, first, count) { commandBuffer.push(33, mode, first, count) }; this.drawElements = function (mode, count, type, offset) { commandBuffer.push(34, mode, count, type, offset) }; this.getError = function () { commandBuffer.push(35); return this.NO_ERROR }; this.createTexture = function () { var id = nextId++; commandBuffer.push(36, id); return new WebGLTexture(id) }; this.deleteTexture = function (texture) { if (!texture) return; commandBuffer.push(37, texture.id); texture.id = 0 }; this.isTexture = function (texture) { return texture && texture.what === "texture" && texture.id > 0 && texture.binding }; this.bindTexture = function (target, texture) { switch (target) { case that.TEXTURE_2D: { bindings.texture2D = texture; break } }if (texture) texture.binding = target; commandBuffer.push(38, target, texture ? texture.id : 0) }; this.texParameteri = function (target, pname, param) { commandBuffer.push(39, target, pname, param) }; this.texImage2D = function (target, level, internalformat, width, height, border, format, type, pixels) { if (pixels === undefined) { format = width; type = height; pixels = border; assert(pixels instanceof Image); assert(internalformat === format && format === this.RGBA); assert(type === this.UNSIGNED_BYTE); var data = pixels.data; width = data.width; height = data.height; border = 0; pixels = new Uint8Array(data.data) } commandBuffer.push(40, target, level, internalformat, width, height, border, format, type, duplicate(pixels)) }; this.compressedTexImage2D = function (target, level, internalformat, width, height, border, pixels) { commandBuffer.push(41, target, level, internalformat, width, height, border, duplicate(pixels)) }; this.activeTexture = function (texture) { commandBuffer.push(42, texture); bindings.activeTexture = texture }; this.getShaderParameter = function (shader, pname) { switch (pname) { case this.SHADER_TYPE: return shader.type; case this.COMPILE_STATUS: { commandBuffer.push(43, shader.id, pname); return true } default: throw "unsupported getShaderParameter " + pname } }; this.clearDepth = function (depth) { commandBuffer.push(44, depth) }; this.depthFunc = function (depth) { commandBuffer.push(45, depth) }; this.frontFace = function (depth) { commandBuffer.push(46, depth) }; this.cullFace = function (depth) { commandBuffer.push(47, depth) }; this.readPixels = function (depth) { abort("readPixels is impossible, we are async GL") }; this.pixelStorei = function (pname, param) { commandBuffer.push(48, pname, param) }; this.depthMask = function (flag) { commandBuffer.push(49, flag) }; this.depthRange = function (near, far) { commandBuffer.push(50, near, far) }; this.blendFunc = function (sfactor, dfactor) { commandBuffer.push(51, sfactor, dfactor); bindings.blendSrcRGB = bindings.blendSrcAlpha = sfactor; bindings.blendDstRGB = bindings.blendDstAlpha = dfactor }; this.scissor = function (x, y, width, height) { commandBuffer.push(52, x, y, width, height) }; this.colorMask = function (red, green, blue, alpha) { commandBuffer.push(53, red, green, blue, alpha) }; this.lineWidth = function (width) { commandBuffer.push(54, width) }; this.createFramebuffer = function () { var id = nextId++; commandBuffer.push(55, id); return new WebGLFramebuffer(id) }; this.deleteFramebuffer = function (framebuffer) { if (!framebuffer) return; commandBuffer.push(56, framebuffer.id) }; this.bindFramebuffer = function (target, framebuffer) { commandBuffer.push(57, target, framebuffer ? framebuffer.id : 0); bindings.framebuffer = framebuffer }; this.framebufferTexture2D = function (target, attachment, textarget, texture, level) { commandBuffer.push(58, target, attachment, textarget, texture ? texture.id : 0, level) }; this.checkFramebufferStatus = function (target) { return this.FRAMEBUFFER_COMPLETE }; this.createRenderbuffer = function () { var id = nextId++; commandBuffer.push(59, id); return new WebGLRenderbuffer(id) }; this.deleteRenderbuffer = function (renderbuffer) { if (!renderbuffer) return; commandBuffer.push(60, renderbuffer.id) }; this.bindRenderbuffer = function (target, renderbuffer) { commandBuffer.push(61, target, renderbuffer ? renderbuffer.id : 0) }; this.renderbufferStorage = function (target, internalformat, width, height) { commandBuffer.push(62, target, internalformat, width, height) }; this.framebufferRenderbuffer = function (target, attachment, renderbuffertarget, renderbuffer) { commandBuffer.push(63, target, attachment, renderbuffertarget, renderbuffer ? renderbuffer.id : 0) }; this.debugPrint = function (text) { commandBuffer.push(64, text) }; this.hint = function (target, mode) { commandBuffer.push(65, target, mode); if (target == this.GENERATE_MIPMAP_HINT) bindings.generateMipmapHint = mode }; this.blendEquation = function (mode) { commandBuffer.push(66, mode); bindings.blendEquationRGB = bindings.blendEquationAlpha = mode }; this.generateMipmap = function (target) { commandBuffer.push(67, target) }; this.uniformMatrix3fv = function (location, transpose, data) { if (!location) return; commandBuffer.push(68, location.id, transpose, new Float32Array(data)) }; this.stencilMask = function (mask) { commandBuffer.push(69, mask) }; this.clearStencil = function (s) { commandBuffer.push(70, s) }; this.texSubImage2D = function (target, level, xoffset, yoffset, width, height, format, type, pixels) { if (pixels === undefined) { var formatTemp = format; format = width; type = height; pixels = formatTemp; assert(pixels instanceof Image); assert(format === this.RGBA); assert(type === this.UNSIGNED_BYTE); var data = pixels.data; width = data.width; height = data.height; pixels = new Uint8Array(data.data) } commandBuffer.push(71, target, level, xoffset, yoffset, width, height, format, type, duplicate(pixels)) }; this.uniform3f = function (location, x, y, z) { if (!location) return; commandBuffer.push(72, location.id, x, y, z) }; this.blendFuncSeparate = function (srcRGB, dstRGB, srcAlpha, dstAlpha) { commandBuffer.push(73, srcRGB, dstRGB, srcAlpha, dstAlpha); bindings.blendSrcRGB = srcRGB; bindings.blendSrcAlpha = srcAlpha; bindings.blendDstRGB = dstRGB; bindings.blendDstAlpha = dstAlpha }; this.uniform2fv = function (location, data) { if (!location) return; commandBuffer.push(74, location.id, new Float32Array(data)) }; this.texParameterf = function (target, pname, param) { commandBuffer.push(75, target, pname, param) }; this.isContextLost = function () { commandBuffer.push(76); return false }; this.isProgram = function (program) { return program && program.what === "program" }; this.blendEquationSeparate = function (rgb, alpha) { commandBuffer.push(77, rgb, alpha); bindings.blendEquationRGB = rgb; bindings.blendEquationAlpha = alpha }; this.stencilFuncSeparate = function (face, func, ref, mask) { commandBuffer.push(78, face, func, ref, mask) }; this.stencilOpSeparate = function (face, fail, zfail, zpass) { commandBuffer.push(79, face, fail, zfail, zpass) }; this.drawBuffersWEBGL = function (buffers) { commandBuffer.push(80, buffers) }; this.uniform1iv = function (location, data) { if (!location) return; commandBuffer.push(81, location.id, new Int32Array(data)) }; this.uniform1fv = function (location, data) { if (!location) return; commandBuffer.push(82, location.id, new Float32Array(data)) }; var theoreticalTracker = new FPSTracker("server (theoretical)"); var throttledTracker = new FPSTracker("server (client-throttled)"); function preRAF() { if (Math.abs(frameId - clientFrameId) >= 4) { return false } } var postRAFed = false; function postRAF() { if (commandBuffer.length > 0) { postMessage({ target: "gl", op: "render", commandBuffer: commandBuffer }); commandBuffer = [] } postRAFed = true } var trueRAF = window.requestAnimationFrame; window.requestAnimationFrame = function (func) { trueRAF(function () { if (preRAF() === false) { window.requestAnimationFrame(func); return } postRAFed = false; func(); if (!postRAFed) { postRAF() } }) } } WebGLWorker.prototype.prefetchedParameters = {}; WebGLWorker.prototype.prefetchedExtensions = {}; WebGLWorker.prototype.prefetchedPrecisions = {}; if (typeof console === "undefined") { var console = { log: function (x) { if (typeof dump === "function") dump("log: " + x + "\n") }, debug: function (x) { if (typeof dump === "function") dump("debug: " + x + "\n") }, info: function (x) { if (typeof dump === "function") dump("info: " + x + "\n") }, warn: function (x) { if (typeof dump === "function") dump("warn: " + x + "\n") }, error: function (x) { if (typeof dump === "function") dump("error: " + x + "\n") } } } function FPSTracker(text) { var last = 0; var mean = 0; var counter = 0; this.tick = function () { var now = Date.now(); if (last > 0) { var diff = now - last; mean = .99 * mean + .01 * diff; if (counter++ === 60) { counter = 0; dump(text + " fps: " + (1e3 / mean).toFixed(2) + "\n") } } last = now } } function PropertyBag() { this.addProperty = function () { }; this.removeProperty = function () { }; this.setProperty = function () { } } var IndexedObjects = { nextId: 1, cache: {}, add: function (object) { object.id = this.nextId++; this.cache[object.id] = object } }; function EventListener() { this.listeners = {}; this.addEventListener = function addEventListener(event, func) { if (!this.listeners[event]) this.listeners[event] = []; this.listeners[event].push(func) }; this.removeEventListener = function (event, func) { var list = this.listeners[event]; if (!list) return; var me = list.indexOf(func); if (me < 0) return; list.splice(me, 1) }; this.fireEvent = function fireEvent(event) { event.preventDefault = function () { }; if (event.type in this.listeners) { this.listeners[event.type].forEach(function (listener) { listener(event) }) } } } function Image() { IndexedObjects.add(this); EventListener.call(this); var src = ""; Object.defineProperty(this, "src", { set: function (value) { src = value; assert(this.id); postMessage({ target: "Image", method: "src", src: src, id: this.id }) }, get: function () { return src } }) } Image.prototype.onload = function () { }; Image.prototype.onerror = function () { }; var window = this; var windowExtra = new EventListener; for (var x in windowExtra) window[x] = windowExtra[x]; window.close = function window_close() { postMessage({ target: "window", method: "close" }) }; window.alert = function (text) { err("alert forever: " + text); while (1) { } }; window.scrollX = window.scrollY = 0; window.WebGLRenderingContext = WebGLWorker; window.requestAnimationFrame = function () { var nextRAF = 0; return function (func) { var now = Date.now(); if (nextRAF === 0) { nextRAF = now + 1e3 / 60 } else { while (now + 2 >= nextRAF) { nextRAF += 1e3 / 60 } } var delay = Math.max(nextRAF - now, 0); setTimeout(func, delay) } }(); var webGLWorker = new WebGLWorker; var document = new EventListener; document.createElement = function document_createElement(what) { switch (what) { case "canvas": { var canvas = new EventListener; canvas.ensureData = function canvas_ensureData() { if (!canvas.data || canvas.data.width !== canvas.width || canvas.data.height !== canvas.height) { canvas.data = { width: canvas.width, height: canvas.height, data: new Uint8Array(canvas.width * canvas.height * 4) }; if (canvas === Module["canvas"]) { postMessage({ target: "canvas", op: "resize", width: canvas.width, height: canvas.height }) } } }; canvas.getContext = function canvas_getContext(type, attributes) { if (canvas === Module["canvas"]) { postMessage({ target: "canvas", op: "getContext", type: type, attributes: attributes }) } if (type === "2d") { return { getImageData: function (x, y, w, h) { assert(x == 0 && y == 0 && w == canvas.width && h == canvas.height); canvas.ensureData(); return { width: canvas.data.width, height: canvas.data.height, data: new Uint8Array(canvas.data.data) } }, putImageData: function (image, x, y) { canvas.ensureData(); assert(x == 0 && y == 0 && image.width == canvas.width && image.height == canvas.height); canvas.data.data.set(image.data); if (canvas === Module["canvas"]) { postMessage({ target: "canvas", op: "render", image: canvas.data }) } }, drawImage: function (image, x, y, w, h, ox, oy, ow, oh) { assert(!x && !y && !ox && !oy); assert(w === ow && h === oh); assert(canvas.width === w || w === undefined); assert(canvas.height === h || h === undefined); assert(image.width === canvas.width && image.height === canvas.height); canvas.ensureData(); canvas.data.data.set(image.data.data); if (canvas === Module["canvas"]) { postMessage({ target: "canvas", op: "render", image: canvas.data }) } } } } else { return webGLWorker } }; canvas.boundingClientRect = {}; canvas.getBoundingClientRect = function canvas_getBoundingClientRect() { return { width: canvas.boundingClientRect.width, height: canvas.boundingClientRect.height, top: canvas.boundingClientRect.top, left: canvas.boundingClientRect.left, bottom: canvas.boundingClientRect.bottom, right: canvas.boundingClientRect.right } }; canvas.style = new PropertyBag; canvas.exitPointerLock = function () { }; canvas.width_ = canvas.width_ || 0; canvas.height_ = canvas.height_ || 0; Object.defineProperty(canvas, "width", { set: function (value) { canvas.width_ = value; if (canvas === Module["canvas"]) { postMessage({ target: "canvas", op: "resize", width: canvas.width_, height: canvas.height_ }) } }, get: function () { return canvas.width_ } }); Object.defineProperty(canvas, "height", { set: function (value) { canvas.height_ = value; if (canvas === Module["canvas"]) { postMessage({ target: "canvas", op: "resize", width: canvas.width_, height: canvas.height_ }) } }, get: function () { return canvas.height_ } }); var style = { parentCanvas: canvas, removeProperty: function () { }, setProperty: function () { } }; Object.defineProperty(style, "cursor", { set: function (value) { if (!style.cursor_ || style.cursor_ !== value) { style.cursor_ = value; if (style.parentCanvas === Module["canvas"]) { postMessage({ target: "canvas", op: "setObjectProperty", object: "style", property: "cursor", value: style.cursor_ }) } } }, get: function () { return style.cursor_ } }); canvas.style = style; return canvas } default: throw "document.createElement " + what } }; document.getElementById = function (id) { if (id === "canvas" || id === "application-canvas") { return Module.canvas } throw "document.getElementById failed on " + id }; document.querySelector = function (id) { if (id === "#canvas" || id === "#application-canvas" || id === "canvas" || id === "application-canvas") { return Module.canvas } throw "document.querySelector failed on " + id }; document.documentElement = {}; document.styleSheets = [{ cssRules: [], insertRule: function (rule, i) { this.cssRules.splice(i, 0, rule) } }]; document.URL = "http://worker.not.yet.ready.wait.for.window.onload?fake"; function Audio() { warnOnce("faking Audio elements, no actual sound will play") } Audio.prototype = new EventListener; Object.defineProperty(Audio.prototype, "src", { set: function (value) { if (value[0] === "d") return; this.onerror() } }); Audio.prototype.play = function () { }; Audio.prototype.pause = function () { }; Audio.prototype.cloneNode = function () { return new Audio }; var screen = { width: 0, height: 0 }; Module.canvas = document.createElement("canvas"); Module.setStatus = function () { }; out = function Module_print(x) { postMessage({ target: "stdout", content: x }) }; err = function Module_printErr(x) { postMessage({ target: "stderr", content: x }) }; var frameId = 0; var clientFrameId = 0; var postMainLoop = Module["postMainLoop"]; Module["postMainLoop"] = function () { if (postMainLoop) postMainLoop(); postMessage({ target: "tick", id: frameId++ }); commandBuffer = [] }; var messageBuffer = null; var messageResenderTimeout = null; function messageResender() { if (calledMain) { assert(messageBuffer && messageBuffer.length > 0); messageResenderTimeout = null; messageBuffer.forEach(function (message) { onmessage(message) }); messageBuffer = null } else { messageResenderTimeout = setTimeout(messageResender, 100) } } function onMessageFromMainEmscriptenThread(message) { if (!calledMain && !message.data.preMain) { if (!messageBuffer) { messageBuffer = []; messageResenderTimeout = setTimeout(messageResender, 100) } messageBuffer.push(message); return } if (calledMain && messageResenderTimeout) { clearTimeout(messageResenderTimeout); messageResender() } switch (message.data.target) { case "document": { document.fireEvent(message.data.event); break } case "window": { window.fireEvent(message.data.event); break } case "canvas": { if (message.data.event) { Module.canvas.fireEvent(message.data.event) } else if (message.data.boundingClientRect) { Module.canvas.boundingClientRect = message.data.boundingClientRect } else throw "ey?"; break } case "gl": { webGLWorker.onmessage(message.data); break } case "tock": { clientFrameId = message.data.id; break } case "Image": { var img = IndexedObjects.cache[message.data.id]; switch (message.data.method) { case "onload": { img.width = message.data.width; img.height = message.data.height; img.data = { width: img.width, height: img.height, data: message.data.data }; img.complete = true; img.onload(); break } case "onerror": { img.onerror({ srcElement: img }); break } }break } case "IDBStore": { assert(message.data.method === "response"); assert(IDBStore.pending); IDBStore.pending(message.data); break } case "worker-init": { Module.canvas = document.createElement("canvas"); screen.width = Module.canvas.width_ = message.data.width; screen.height = Module.canvas.height_ = message.data.height; Module.canvas.boundingClientRect = message.data.boundingClientRect; document.URL = message.data.URL; window.fireEvent({ type: "load" }); removeRunDependency("worker-init"); break } case "custom": { if (Module["onCustomMessage"]) { Module["onCustomMessage"](message) } else { throw "Custom message received but worker Module.onCustomMessage not implemented." } break } case "setimmediate": { if (Module["setImmediates"]) Module["setImmediates"].shift()(); break } default: throw "wha? " + message.data.target } } onmessage = onMessageFromMainEmscriptenThread; if (typeof __specialEventTargets !== "undefined") { __specialEventTargets = [0, document, window] } } Module["asm"] = asm; Module["cwrap"] = cwrap; Module["getMemory"] = getMemory; Module["addRunDependency"] = addRunDependency; Module["removeRunDependency"] = removeRunDependency; Module["FS_createFolder"] = FS.createFolder; Module["FS_createPath"] = FS.createPath; Module["FS_createDataFile"] = FS.createDataFile; Module["FS_createPreloadedFile"] = FS.createPreloadedFile; Module["FS_createLazyFile"] = FS.createLazyFile; Module["FS_createLink"] = FS.createLink; Module["FS_createDevice"] = FS.createDevice; Module["FS_unlink"] = FS.unlink; Module["FS"] = FS; var calledRun; Module["then"] = function (func) { if (calledRun) { func(Module) } else { var old = Module["onRuntimeInitialized"]; Module["onRuntimeInitialized"] = function () { if (old) old(); func(Module) } } return Module }; function ExitStatus(status) { this.name = "ExitStatus"; this.message = "Program terminated with exit(" + status + ")"; this.status = status } var calledMain = false; dependenciesFulfilled = function runCaller() { if (!calledRun) run(); if (!calledRun) dependenciesFulfilled = runCaller }; function run(args) { args = args || arguments_; if (runDependencies > 0) { return } preRun(); if (runDependencies > 0) return; function doRun() { if (calledRun) return; calledRun = true; Module["calledRun"] = true; if (ABORT) return; initRuntime(); preMain(); if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"](); postRun() } if (Module["setStatus"]) { Module["setStatus"]("Running..."); setTimeout(function () { setTimeout(function () { Module["setStatus"]("") }, 1); doRun() }, 1) } else { doRun() } } Module["run"] = run; function exit(status, implicit) { if (implicit && noExitRuntime && status === 0) { return } if (noExitRuntime) { } else { ABORT = true; EXITSTATUS = status; exitRuntime(); if (Module["onExit"]) Module["onExit"](status) } quit_(status, new ExitStatus(status)) } if (Module["preInit"]) { if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]]; while (Module["preInit"].length > 0) { Module["preInit"].pop()() } } noExitRuntime = true; run();


                return Module
            }
        );
    })();

    let mecab = null;
    let mecabDo = null;
    const args = '-r mecabrc -d unidic/ input.txt -o output.txt'
    const spaceRegex = /[\s\n]/g;

    Module().then(instance => {
        mecab = instance
        mecab.FS.createDataFile('/', 'input.txt', '', true, true);
        mecabDo = mecab.cwrap('mecab_do2', 'number', ['string'])
    })
    console.log('web worker start')

    onconnect = function (e) {
        var port = e.ports[0];

        port.onmessage = function (e) {
            const objData = e.data;
            const text = objData.text
            const processedText = text.replace(spaceRegex, "、")
            mecab.FS.writeFile('input.txt', processedText)
            mecabDo(args);
            const output = mecab.FS.readFile('output.txt', { encoding: "utf8" });
            port.postMessage({ output, timestamp: objData.timestamp })
        }

        port.start();
    }
}


